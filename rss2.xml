<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>胜哥爱周周</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>仰望星空，脚踏实地</description>
    <pubDate>Wed, 22 Mar 2023 10:00:59 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>DMA</title>
      <link>http://example.com/2023/03/20/DMA/</link>
      <guid>http://example.com/2023/03/20/DMA/</guid>
      <pubDate>Mon, 20 Mar 2023 05:11:47 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-0-DMA&quot;&gt;&lt;a href=&quot;#1-0-DMA&quot; class=&quot;headerlink&quot; title=&quot;1.0-DMA&quot;&gt;&lt;/a&gt;1.0-DMA&lt;/h1&gt;&lt;h2 id=&quot;1-1-DMA背景及基本定义&quot;&gt;&lt;a href=&quot;#1-1-DMA背景及基本定义&quot; cla</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-0-DMA"><a href="#1-0-DMA" class="headerlink" title="1.0-DMA"></a>1.0-DMA</h1><h2 id="1-1-DMA背景及基本定义"><a href="#1-1-DMA背景及基本定义" class="headerlink" title="1.1-DMA背景及基本定义"></a>1.1-DMA背景及基本定义</h2><p>DMA，全称Direct Memory Access，即直接存储器访问。DMA传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。我们知道CPU有转移数据、计算、控制程序转移等很多功能，系统运作的核心就是CPU，CPU无时不刻的在处理着大量的事务，但有些事情却没有那么重要，比方说数据的复制和存储数据，如果我们把这部分的CPU资源拿出来，让CPU去处理其他的复杂计算事务，是不是能够更好的利用CPU的资源呢？<br>因此：转移数据（尤其是转移大量数据）是可以不需要CPU参与。比如希望外设A的数据拷贝到外设B，只要给两种外设提供一条数据通路，直接让数据由A拷贝到B 不经过CPU的处理。<br>DMA就是基于以上设想设计的，它的作用就是解决大量数据转移过度消耗CPU资源的问题。有了DMA使CPU更专注于更加实用的操作–计算、控制等。<br>综上所述我们给出DMA的定义：<br><strong>DMA用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。无须CPU的干预，通过DMA数据可以快速地移动。这就节省了CPU的资源来做其他操作。</strong>  </p><h2 id="1-2-DMA传输方式"><a href="#1-2-DMA传输方式" class="headerlink" title="1.2-DMA传输方式"></a>1.2-DMA传输方式</h2><p>DMA的作用就是实现数据的直接传输，而去掉了传统数据传输需要CPU寄存器参与的环节，主要涉及四种情况的数据传输，但本质上是一样的，都是从内存的某一区域传输到内存的另一区域（外设的数据寄存器本质上就是内存的一个存储单元）。四种情况的数据传输如下：<br>外设到内存、内存到外设、内存到内存  </p><h2 id="1-3-DMA主要特征"><a href="#1-3-DMA主要特征" class="headerlink" title="1.3-DMA主要特征"></a>1.3-DMA主要特征</h2><p>1、每个通道都直接连接专用的硬件DMA请求，每个通道都同样支持软件触发。这些功能通过软件来配置；<br>2、在同一个DMA模块上，多个请求间的优先权可以通过软件编程设置（共有四级：很高、高、中等和低），优先权设置相等时由硬件决定（请求0优先于请求1，依此类推）；<br>3、独立数据源和目标数据区的传输宽度（字节、半字、全字），模拟打包和拆包的过程。源和目标地址必须按数据传输宽度对齐；<br>4、支持循环的缓冲器管理；<br>5、每个通道都有3个事件标志（DMA半传输、DMA传输完成和DMA传输出错），这3个事件标志逻辑或成为一个单独的中断请求；<br>6、存储器和存储器间的传输、外设和存储器、存储器和外设之间的传输；<br>7、闪存、SRAM、外设的SRAM、APB1、APB2和AHB外设均可作为访问的源和目标；<br>8、可编程的数据传输数目：最大为65535。  </p><h2 id="1-4-DMA通道"><a href="#1-4-DMA通道" class="headerlink" title="1.4-DMA通道"></a>1.4-DMA通道</h2><p>对于大容量的STM32芯片有2个DMA控制器两个DMA控制器，DMA1有7个通道，DMA2有5个通道。每个通道都可以配置一些外设的地址。<br><strong>(一)、DMA1 controller：</strong><br>从外设（TIMx[x&#x3D;1、2、3、4]、ADC1、SPI1、SPI&#x2F;I2S2、I2Cx[x&#x3D;1、2]和USARTx[x&#x3D;1、2、3]）产生的7个DMA请求，通过逻辑或输入到DMA1控制器 其中每个通道都对应着具体的外设。<br>DMA1请求映像：<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/8f94491dd43de9783fa2983bbb14049.png" style="zoom: 75%;"/><br>各个通道的DMA1请求一览：<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/3caed66acd97325fa885997e1b4055c.png" style="zoom: 100%;"/><br><strong>（二）、DMA2 controller：</strong><br>从外设（TIMx[5、6、7、8]、ADC3、SPI&#x2F;I2S3、UART4、DAC通道1、2和SDIO）产生的5个请求，经逻辑或输入到DMA2控制器，其中每个通道都对应着具体的外设。<br>DMA2请求映像：<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/345180291a5df2accc4e5cc2c4da568.png" style="zoom: 75%;"/><br>各个通道的DMA2请求一览：<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/010e02104f5b32ce36aaaa05f260c3c.png"/></p><h2 id="1-5-DMA工作框图"><a href="#1-5-DMA工作框图" class="headerlink" title="1.5-DMA工作框图"></a>1.5-DMA工作框图</h2><p>可以看到STM32内核，存储器，外设及DMA的连接，这些硬件最终通过各种各样的线连接到总线矩阵中，硬件结构之间的数据转移都经过总线矩阵的协调，使各个外设和谐的使用总线来传输数据。现在对有无DMA的数据传输进行判断。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/b3d84cf663f3e7e23e7f20d914cf535.png" style="zoom: 75%;"/></p><h2 id="1-5-1-无DMA"><a href="#1-5-1-无DMA" class="headerlink" title="1.5.1-无DMA"></a>1.5.1-无DMA</h2><p>如果没有DMA,CPU传输数据还要以内核作为中转站，比如要将ADC采集的数据转移到到SRAM中，这个过程是这样的：<br>内核通过DCode经过总线矩阵协调，从获取AHB存储的外设ADC采集的数据。<br>然后内核再通过DCode经过总线矩阵协调把数据存放到内存SRAM中。<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/20230321190648.png"/>DCode中的D表示Data，既数据，这就表示这条总线是用来读取数据的。我们在写程序的时候，数据有变量和常量两种，常量在C语言中用const关键字修饰，是存放在内部Flash存储器中的；变量是可变的，不管是全局变量还是局部变量都统一存放在SRAM存储器当中。因为数据可以被DCode总线和DMA总线访问，为了避免访问冲突，在读取数据时需要经过一个总线矩阵来仲裁，来决定是哪根总线读取数据。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</category>
      
      
      
      <comments>http://example.com/2023/03/20/DMA/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>STM32通信</title>
      <link>http://example.com/2023/03/07/STM32%E9%80%9A%E4%BF%A1%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE/</link>
      <guid>http://example.com/2023/03/07/STM32%E9%80%9A%E4%BF%A1%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Tue, 07 Mar 2023 06:11:11 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-0-数据通信方式&quot;&gt;&lt;a href=&quot;#1-0-数据通信方式&quot; class=&quot;headerlink&quot; title=&quot;1.0-数据通信方式&quot;&gt;&lt;/a&gt;1.0-数据通信方式&lt;/h1&gt;&lt;h2 id=&quot;1-1-串行与并行通信方式&quot;&gt;&lt;a href=&quot;#1-1-串行与并</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-0-数据通信方式"><a href="#1-0-数据通信方式" class="headerlink" title="1.0-数据通信方式"></a>1.0-数据通信方式</h1><h2 id="1-1-串行与并行通信方式"><a href="#1-1-串行与并行通信方式" class="headerlink" title="1.1-串行与并行通信方式"></a>1.1-串行与并行通信方式</h2><p><strong>串行通讯：</strong><br>是指设备之间通过一根数据信号线，地线以及控制信号线，按数据位形式一位一位地传输数据的通讯方式，同一时刻只能传输一位(bit)数据。<br><strong>并行通讯：</strong><br>是指使用 8、16、32 及 64 根或更多的数据线(有多少信号为就需要多少信号位)进行传输的通讯方式，可以同一时刻传输多个数据位的数据。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/8f749a56006b600721c020526e1ed06.png"  style="zoom: 50%;" /><br><strong>串行与并行通信优缺点：</strong>  </p><table><thead><tr><th align="center">特性</th><th align="center">串行通讯</th><th align="center">并行通讯</th></tr></thead><tbody><tr><td align="center">通讯距离</td><td align="center">较远</td><td align="center">较近</td></tr><tr><td align="center">抗干扰能力</td><td align="center">较强</td><td align="center">较弱</td></tr><tr><td align="center">传输速率</td><td align="center">较慢</td><td align="center">较高</td></tr><tr><td align="center">成本</td><td align="center">较低</td><td align="center">较高</td></tr></tbody></table><p>并行可以同时发送多位数据所以速度比串行的速度要快很多，但并行要的数据线也更多相对成本会更高，而且并行传输对同步要求较高，且随着通讯速率的提高，信号干扰的问题会显著影响通讯性能。</p><h2 id="1-2-全双工、半双工及单工通讯"><a href="#1-2-全双工、半双工及单工通讯" class="headerlink" title="1.2-全双工、半双工及单工通讯"></a>1.2-全双工、半双工及单工通讯</h2><p><strong>单工通信：</strong><br>信息只能单方向传输的工作方式，一个固定为发送设备，另一个固定为接收设备，发送端只能发送信息不能接收信息，接收端只能接收信息不能发送信息，只需一根信号线。举例：广播、电视。<br><strong>半双工通信：</strong><br>可以实现双向的通信，但不能在两个方向上同时进行，必须轮流交替进行，其实也可以理解成一种可以切换方向的单工通信，同一时刻必须只能一个方向传输，只需一根数据线。举例：对讲机。<br><strong>全双工通信：</strong><br>在同一时刻，两个设备之间可以同时收发数据，全双工方式无需进行方向的切换，这种方式要求通讯双方均有发送器和接收器，同时，需要2根数据线。举例：电话。  </p><h2 id="1-3-同步通信与异步通信"><a href="#1-3-同步通信与异步通信" class="headerlink" title="1.3-同步通信与异步通信"></a>1.3-同步通信与异步通信</h2><p>根据通讯的数据同步方式，又分为同步和异步两种，可以根据通讯过程中是否有使用到时钟信号进行简单的区分。<br><strong>同步通讯：</strong><br>收发设备双方会使用一根信号线表示时钟信号，在时钟信号的驱动下双方进行协调，同步数据，通讯中通常双方会统一规定在时钟信号的上升沿或下降沿对数据线进行采样，对应时钟极性与时钟相位。<br><strong>异步通讯：</strong><br>不需要时钟信号进行数据同步，它们直接在数据信号中穿插一些同步用的信号位，或者把主体数据进行打包，以数据帧（串口：起始位 数据 校验位(可以没有) 停止位）的格式传输数据，某些通讯中还需要双方约定数据的传输速率（波特率），以便更好地同步。<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/0d0f6022025c136a38756cef510ca54.png"></p><h2 id="1-4-常见串口通信接口："><a href="#1-4-常见串口通信接口：" class="headerlink" title="1.4-常见串口通信接口："></a>1.4-常见串口通信接口：</h2><table><thead><tr><th align="center">通信标准</th><th align="center">引脚说明</th><th align="center">通信方式</th><th align="center">通信方向</th></tr></thead><tbody><tr><td align="center">UART(通用异步收发器)</td><td align="center">TXD:发送端、RXD:接受端、GND：公共端</td><td align="center">异步通信</td><td align="center">全双工</td></tr><tr><td align="center">单总线(1-wire)</td><td align="center">DQ:发送&#x2F;接受端</td><td align="center">异步通信</td><td align="center">半双工</td></tr><tr><td align="center">SPI</td><td align="center">SCK:同步时钟、MISO:主机输入，从机输出、MOSI:主机输出，从机输入</td><td align="center">同步通信</td><td align="center">全双工</td></tr><tr><td align="center">I2C</td><td align="center">SCL:同步时钟、SDA:数据输入&#x2F;输出端</td><td align="center">同步通信</td><td align="center">半双工</td></tr></tbody></table><h1 id="2-0-串口通讯协议"><a href="#2-0-串口通讯协议" class="headerlink" title="2.0-串口通讯协议"></a>2.0-串口通讯协议</h1><p><strong>通讯协议：</strong><br>分为物理层和协议层。物理层规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输（通俗一点就是硬件部分）。协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准（软件）。<br><strong>STM32串口简介:</strong><br>USART-通用同步异步收发器(Universal Synchronous Asynchronous Receiver and Transmitter)是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换。有别于 USART 还有一个UART(Universal Asynchronous Receiver and Transmitter)，它是在 USART 基础上裁剪掉了同步通信功能（时钟同步），只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是UART。<br><strong>串行通信一般是以帧格式传输数据，即是一帧一帧的传输，每帧包含有起始信号、数据信息、校验信息(由我们自己设置)、停止信号。</strong>  </p><h2 id="2-1-物理层"><a href="#2-1-物理层" class="headerlink" title="2.1-物理层"></a>2.1-物理层</h2><h3 id="2-1-1-RS232标准"><a href="#2-1-1-RS232标准" class="headerlink" title="2.1.1-RS232标准"></a>2.1.1-RS232标准</h3><p>很多单片机内部例如我们所用的STM32，以及一些传感器一般都是TTL电平。RS232是一种串行数据传输形式，称其为串行连接，最经典的标志就是9针孔的DB9电缆RS232电压表示逻辑1 ，0的范围大极大的增强了容错率，主要用于工业设备直接通信。</p><table><thead><tr><th align="center">通信标准</th><th align="center">电平标准</th></tr></thead><tbody><tr><td align="center">TTL</td><td align="center">逻辑1：2.4V ~ 5V         逻辑0：0 ~ 0.5V</td></tr><tr><td align="center">RS-232</td><td align="center">逻辑1:-15V ~ -3V      逻辑0：+3V ~ +15V</td></tr></tbody></table><p>由上表格可知，TLL与RS-232标准逻辑相反，而且电平也大不相同，若单片机与单片机或其他设备TLL设备通信采用RS-232通信（DB9）,肯定先要进行电平的转化TLL-&gt;RS232 RS232-&gt;TTL。<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/66a036b56f2050ca8886b3760970a42.png">两个通讯设备的“DB9 接口”之间通过串口信号线建立起连接，串口信号线中使用“RS-232标准”传输数据信号。由于RS-232电平标准的信号不能直接被控制器直接识别，所以这些信号会经过一个“电平转换芯片”转换成控制器能识别的“TTL 标准”的电平信号，才能实现通讯。电平转换芯片常有：MAX3232、SP3232 <img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/87c50ab22f4f4ff2a3a226633fe994a.png"  style="zoom: 45%;" /></p><h3 id="2-1-2-USB转串口标准"><a href="#2-1-2-USB转串口标准" class="headerlink" title="2.1.2-USB转串口标准"></a>2.1.2-USB转串口标准</h3><p>USB转串口：主要用于设备(STM32)与电脑通信。电平转换芯片一般有CH340、PL2303、CP2102、FT232。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/1c96c5860ef7a381d3ca997192f93a8.png">使用时要注意安装CH340驱动。<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/dd6ac179bac3559cda734e4148b0ca8.jpg"  style="zoom: 33%;" />USB转串口原理图：<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/0ad892459721eca3b28560aed015365.png"></p><h3 id="2-1-3-原生的串口到串口标准"><a href="#2-1-3-原生的串口到串口标准" class="headerlink" title="2.1.3-原生的串口到串口标准"></a>2.1.3-原生的串口到串口标准</h3><p>原生的串口通信主要是控制器跟串口的设备或者传感器通信他们但是TLL电平，不需要经过电平转换芯片来转换电平，直接就用TTL电平通信，GPS模块、GSM模块、串口转WIFI模块、HC04蓝牙模块<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/e1a1087ae519f5085017a69248c864c.png"></p><h2 id="2-2-协议层"><a href="#2-2-协议层" class="headerlink" title="2.2-协议层"></a>2.2-协议层</h2><p>串口通讯的协议层中，规定了数据包的内容，它由启始位、主体数据、校验位以及停止位组成，通讯双方的数据包格式要约定一致（一样的起始位 数据 校验位 停止位）才能正常收发数据<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/b23e7254e6a5d6870a8d7455ef39495.png"><br><strong>通讯的起始和停止信号：</strong><br>串口通讯的一个数据包从起始信号开始，直到停止信号结束。数据包的起始信号由一个逻辑 0 的数据位表示，而数据包的停止信号可由 0.5、1、1.5 或 2 个逻辑 1 的数据位表示。在USART_CR2中编程停止位的位数。<br>1个停止位：停止位位数的默认值。<br>2个停止位：可用于常规USART模式、单线模式以及调制解调器模式。<br>0.5个停止位：在智能卡模式下接收数据时使用。<br>1.5个停止位：在智能卡模式下发送和接收数据时使用。<br><strong>有效数据：</strong><br>在数据包的起始位之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的长度常被约定为 5、6、7 或 8 位长。<br><strong>数据校验：</strong><br>（1）、偶校验：校验位使得一帧中的7或8个LSB数据以及校验位中’1’的个数为偶数。例如：数据&#x3D;00110101，有4个’1’，如果选择偶校验(在USART_CR1中的PS＝0)，校验位将是’0’，最后数据检验如果数据有偶数个1则数据传输没有出错(但不是绝对的，如果同时两个数据为发送错误(0变成1)则还是偶数个。<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/c9a6a3ee43f2bd4ddecc16286e7b25f.png"  style="zoom: 33%;" />（2）、奇校验：此校验位使得一帧中的7或8个LSB数据以及校验位中’1’的个数为奇数。例如：数据&#x3D;00110101，有4个’1’，如果选择奇校验(在USART_CR1中的PS＝1)，校验位将是’1’，最后数据检验如果数据有奇数个1则数据传输没有出错，但同样不是绝对的(同时两个1变成0)。  </p><h2 id="2-3-USART-功能框图"><a href="#2-3-USART-功能框图" class="headerlink" title="2.3-USART 功能框图"></a>2.3-USART 功能框图</h2><p><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/ebcbfb009a99f7b3d0392312d174505.png"  style="zoom: 75%;" />现在对USART的功能框图的各个部分进行分析。</p><h3 id="2-3-1-功能引脚"><a href="#2-3-1-功能引脚" class="headerlink" title="2.3.1-功能引脚"></a>2.3.1-功能引脚</h3><p><strong>TX：</strong>发送数据输出引脚。<br><strong>RX：</strong>接收数据输入引脚。<br><strong>SCLK：</strong>发送器时钟输出引脚。这个引脚仅适用于同步模式。<br><strong>SW_RX：</strong>数据接收引脚，只用于单线和智能卡模式，属于内部引脚，没有具体外部引脚。<br><strong>nRTS：</strong>请求以发送(Request To Send)， n 表示低电平有效。如果使能 RTS 流控制，当<br>USART 接收器准备好接收新数据时就会将 nRTS 变成低电平；当接收寄存器已满时， nRTS<br>将被设置为高电平。该引脚只适用于硬件流控制。<br><strong>nCTS：</strong>清除以发送(Clear To Send)， n表示低电平有效。如果使能 CTS 流控制，发送器<br>在发送下一帧数据之前会检测 nCTS 引脚，如果为低电平，表示可以发送数据，如果为高<br>电平则在发送完当前数据帧之后停止发送。该引脚只适用于硬件流控制。<br><strong>SW_RX、nRTS、nCTS不常用</strong><br>以下引脚都是默认功能引脚，而不是复用功能引脚：  </p><table>    <tr> <!-- 第一行数据 -->        <th style="text-align:center" colspan="6"> STM32F103VET6 芯片的 USART 引脚 </th> <!-- 表头，用于居中显示；合并 9 行为 CBW 数据封包 -->    </tr>    <tr> <!-- 第二行数据 -->        <th style="text-align:center" rowspan="2"> 引脚 </th> <!-- 表头，用于居中显示；合并 2 行为 字节 -->        <th style="text-align:center"  colspan="1"> APB1总线 </th>  <!-- 表头，用于居中显示；合并 1 列 -->        <th style="text-align:center"  colspan="4"> APB1总线 </th>  <!-- 表头，用于居中显示；合并 8 列 -->    </tr>    <tr> <!-- 第三行数据 -->    <td> USART1 </td>    <td> USART2 </td>    <td> USART3 </td>    <td> USART4 </td>    <td> USART5</td>    </tr>    </tr>    <td> TX </td>    <td> PA9 </td>    <td> PA2 </td>    <td> PB10 </td>    <td> PC10 </td>    <td> PC12 </td>    </tr>    </tr>    <td> RX </td>    <td> PA10</td>    <td> PA3 </td>    <td> PB11</td>    <td> PC11 </td>    <td> PD2 </td>    </tr>    </tr>    <td> SCLK </td>    <td> PA8 </td>    <td> PA4 </td>    <td> PB12 </td>    <td>  </td>    <td>  </td>    </tr>    </tr>    <td> nCTS </td>    <td> PA11 </td>    <td> PA0 </td>    <td> PB13 </td>    <td>  </td>    <td>  </td>    </tr>    </tr>    <td> nRTS </td>    <td> PA12 </td>    <td> PA1 </td>    <td> PB14 </td>    <td>  </td>    <td>  </td>    </tr></table><p>功能所对应的引脚是查阅STM32f10x数据手册得知的，表格如下所示。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/282bfa66a183e2f99135c98c695b07f.png#pic_center=200x">表格中还出现了复用功能，如图所示<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/87aaf1556b153d3efc50005d5166c91.png">，这是为了在大型项目中能灵活使用引脚。若使用复用功能则必须配置AFIO，详细可查阅数据手册。</p><h3 id="2-3-2-读写单元"><a href="#2-3-2-读写单元" class="headerlink" title="2.3.2-读写单元"></a>2.3.2-读写单元</h3><p><strong>数据寄存器-USART_DR:</strong><br>9位有效，包含一个发送数据寄存器TDR和一个接受数据寄存器RDR。<font color="#dd0000">一个地址对应了两个物理内存</font><br /><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/1267c7efa31388d249835414cb29f3c.png">TDR和RDR都是介于系统总线和移位寄存器之间。发送时把TDR内容并行发送到移位寄存器，然后把移位寄存器数据每一位发送出去。接收时把接收到的每一位顺序保存在接收移位寄存器内然后才并行转移到RDR.<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/87687aea4dbeb800a38e60e9601fe3b.png">在stm32f10x_usart.c文件中有发送数据以及接收数据的相关函数。</p><pre><code>void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)&#123;  /* Check the parameters */  assert_param(IS_USART_ALL_PERIPH(USARTx));  assert_param(IS_USART_DATA(Data));       /* Transmit Data */  USARTx-&gt;DR = (Data &amp; (uint16_t)0x01FF);//发送数据就是CPU通过总线往DR寄存器写入数据&#125;uint16_t USART_ReceiveData(USART_TypeDef* USARTx)&#123;  /* Check the parameters */  assert_param(IS_USART_ALL_PERIPH(USARTx));    /* Receive Data */  return (uint16_t)(USARTx-&gt;DR &amp; (uint16_t)0x01FF);//接收数据就是CPU通过总线往DR寄存器读出数据&#125;</code></pre><p><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/0183b5a335210b63cb7dc0116cff7b4.png"></p><h3 id="2-3-3-控制单元"><a href="#2-3-3-控制单元" class="headerlink" title="2.3.3-控制单元"></a>2.3.3-控制单元</h3><h4 id="2-3-3-1-发送器"><a href="#2-3-3-1-发送器" class="headerlink" title="2.3.3.1-发送器"></a>2.3.3.1-发送器</h4><p>发送器根据M位的状态发送8位或9位的数据字。当发送使能位(TE)被设置时，发送移位寄存器中的数据在TX脚上输出，相应的时钟脉冲在CK脚上输出。一个字符帧发送需要三个部分：起始位+数据帧（可能有校验位）+停止位。每个字符(一个数据帧)之前都有一个低电平的起始位，之后跟着的停止位，其数目可配置,数据帧就是我们要发送的 8 位或 9 位数据，数据是从最低位开始传输的,停止位是一定时间周期的高电平。<br><strong>发送过程配置步骤（void USART_Config(void)函数配置）</strong><br><strong>1、激活USART</strong><br>通过在USART_CR1寄存器上置位UE位来激活USART，在stm32f10x_usart.c文件中调用该寄存器的配置函数：void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)。</p><pre><code>void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)&#123;  /* Check the parameters */  assert_param(IS_USART_ALL_PERIPH(USARTx));  assert_param(IS_FUNCTIONAL_STATE(NewState));    if (NewState != DISABLE)  &#123;    /* Enable the selected USART by setting the UE bit in the CR1 register */    USARTx-&gt;CR1 |= CR1_UE_Set;  &#125;  else  &#123;    /* Disable the selected USART by clearing the UE bit in the CR1 register */    USARTx-&gt;CR1 &amp;= CR1_UE_Reset;  &#125;&#125;</code></pre><p><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/c300729f189b5d33f0dd8ca7582d7d1.png"><br><strong>2、定义数据字长</strong><br>编程USART_CR1的M位来定义字长。在stm32f10x_usart.h文件中定义了关于USART的结构体USART_InitTypeDef，给该结构体的成员USART_WordLength赋相应的值即可。 <img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/edd216e3c33c8fad681f6227b639f8f.png"><br><strong>3、确定停止位数</strong><br>在USART_CR2中编程停止位的位数。在stm32f10x_usart.h文件中定义了关于USART的结构体USART_InitTypeDef，给该结构体的成员USART_StopBits赋相应的值即可。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/787c50d94baf758fa35dc98a1b8ae7d.png"><br><strong>4、使能DMA</strong><br>如果采用多缓冲器通信，配置USART_CR3中的DMA使能位(DMAT)。按多缓冲器通信中的描述配置DMA寄存器,关于DMA下期再详细讲解。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/88bdd5d13618b9c0e27adcc15d0c187.png"><br><strong>5、确定波特率</strong><br>利用USART_BRR寄存器选择要求的波特率。在stm32f10x_usart.h文件中定义了关于USART的结构体USART_InitTypeDef，给该结构体的成员USART_BaudRate赋相应的值即可。例如</p><pre><code>#define  DEBUG_USART_BAUDRATE           115200USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;    </code></pre><p>波特率指数据信号对载波的调制速率， 它用单位时间内载波调制状态改变次数来表示，单位为波特。比特率指单位时间内传输的比特数，单位 bit&#x2F;s(bps)。对于USART波特率与比特率相等，以后不区分这两个概念。波特率越大，传输速率越快。USART 的发送器和接收器使用相同的波特率。计算公式如下：<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/8379bdf54d1080c80d00ade995eb240.png"  style="zoom: 33%;" />其中， fPLCK 为 USART 时钟， USARTDIV 是一个存放在波特率寄存器(USART_BRR)的 一 个 无符号定点数。其中DIV_Mantissa[11:0]位定义USARTDIV的整数部分，DIV_Fraction[3:0]位定义 USARTDIV 的小数部分。<br>例如： DIV_Mantissa&#x3D;24(0x18)，DIV_Fraction&#x3D;10(0x0A)，此时USART_BRR值为0x18A；那么USARTDIV的小数位10&#x2F;16&#x3D;0.625；整数位24，最终USARTDIV的值为24.625。<br>如果知道 USARTDIV 值为 27.68，那么 DIV_Fraction&#x3D;16*0.68&#x3D;10.88，最接近的正整数为 11，所以 DIV_Fraction[3:0]为 0xB； DIV_Mantissa&#x3D;整数(27.68)&#x3D;27，即为 0x1B。波特率的常用值有 2400、 9600、 19200、 115200。下面以实例讲解如何设定寄存器值得到波特率的值。<br>我们知道 USART1 使用 APB2 总线时钟，最高可达 72MHz，其他 USART 的最高频率为 36MHz。我们选取USART1作为实例讲解，即fPLCK&#x3D;72MHz。为得到 115200bps 的波特率，此时：115200 &#x3D;7200000016 ✖ USARTDIV解得USARTDIV&#x3D;39.0625，可算得DIV_Fraction&#x3D;0.0625✖16&#x3D;1&#x3D;0x01 ，DIV_Mantissa&#x3D;39&#x3D;0x17，即应该设置USART_BRR的值为0x171。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/7d7f81325c591c20b1502e120f4f017.png" style="zoom: 75%;"/><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/64a8c90da0936dbc542b396b1d4f788.png" style="zoom: 75%;"/><br><strong>6、确定USART模式</strong><br>设置USART_CR1中的TE位，发送一个空闲帧帧(一个数据帧长度的高电平)作为第一次数据发送。这两位在USART_InitTypeDef成员中的USART_Mode中设置，USART模式选择有 USART_Mode_Rx和 USART_Mode_Tx，允许使用逻辑或运算选择两个，它设定USART_CR1寄存器的RE位和TE位。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/46820f13d43ad2b6e4cec7f7316c181.png"></p><pre><code>// 配置工作模式，收发一起USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</code></pre><p>在文件stm32f10x_usart.h中定义了这两个宏  </p><pre><code>#define USART_Mode_Rx                ((uint16_t)0x0004)#define USART_Mode_Tx                ((uint16_t)0x0008)</code></pre><p><strong>7、配置校验位</strong><br>STM32F103 系列控制器USART支持奇偶校验。当使用校验位时，串口传输的长度将是8位的数据帧加上1位的校验位总共9位，此时USART_CR1寄存器的M位需要设置为1，即9数据位。将USART_CR1寄存器的PCE位置1就可以启动奇偶校验控制，奇偶校验由硬件自动完成。启动了奇偶校验控制之后，在发送数据帧时会自动添加校验位，接收数据时自动验证校验位。接收数据时如果出现奇偶校验位验证失败，会见USART_SR寄存器的PE位置1，并可以产生奇偶校验中断。使能了奇偶校验控制后，每个字符帧的格式将变成：起始位+数据帧+校验位+停止位。<br>USART_CR1寄存器的PCE (Parity control enable)位，检验控制使能即选择或者不选择校验。<br>USART_CR1寄存器的PS (Parity selection)位，校验选择，在使能的基础上选择奇校验或偶校验。<br>USART_SR寄存器的PE(Parity error)位，判断是否校验错误，产生中断。  <img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/0015b89f673e37a23b779fdea1e4ec8.png"/><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/cd0254221fd4203c9ca906aaf3fdbf7.png"/><br><strong>8、硬件流控制选择</strong><br>这里讲到的 “流”，指的是数据流；在数据通信中，流控制是管理两个节点之间数据传输速率的过程，以防止出现接收端的数据缓冲区已满，而发送端依然继续发送数据，所导致数据丢失。当接收端的数据缓冲区已满，无法处理数据来时，就发出 “不再接收” 的信号，发送端则停止发送，直到发送端收到 “可以继续发送” 的信号再发送数据。计算机中常用的两种流控制分别是硬件流控制（RTS &#x2F;CTS、DTR &#x2F;DSR等）和软件流控制（XON &#x2F;XOFF）。<br><strong>9、判断数据是否全部转移到移位寄存器</strong><br>把要发送的数据写进USART_DR寄存器(此动作清除TXE位)。在只有一个缓冲器的情况下，对每个待发送的数据重复步骤7。注意连续发送多个数据的时候要判断上一帧数据是否全部从TDR寄存器中转移到移位寄存器里，所使用的寄存器是状态寄存器(USART_SR)中的位7(TXE发送数据寄存器空)<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/689c4f10fea67c84e7c72a5fc4f279c.png" style="zoom: 75%;"/>需要调用stm32f10x_usart.c文件中的函数。</p><pre><code>FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)&#123;  FlagStatus bitstatus = RESET;  /* Check the parameters */  assert_param(IS_USART_ALL_PERIPH(USARTx));  assert_param(IS_USART_FLAG(USART_FLAG));  /* The CTS flag is not available for UART4 and UART5 */  if (USART_FLAG == USART_FLAG_CTS)  &#123;    assert_param(IS_USART_123_PERIPH(USARTx));  &#125;      if ((USARTx-&gt;SR &amp; USART_FLAG) != (uint16_t)RESET)  &#123;    bitstatus = SET;  &#125;  else  &#123;    bitstatus = RESET;  &#125;  return bitstatus;&#125;</code></pre><p>调用该函数的语句如下：</p><pre><code>while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TC)== RESET);</code></pre><p><strong>10、判断移位寄存器是否将数据全部发送出去</strong><br>在USART_DR寄存器中写入最后一个数据字后，要等待状态寄存器(USART_SR)中的位TC&#x3D;1，它表示最后一个数据帧的传输结束(移位寄存器中的数据全部发送完毕)。当需要关闭USART或需要进入停机模式之前，需要确认传输结束，避免破坏最后一次传输。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/e9a214fe93ff1bcfe675f4625fee255.png"/>同第七步一样也是调用FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)函数来判断TC位是否等于1（即数据是否全部从发送移位寄存器中串行发送出去）。调用函数语句如下：</p><pre><code>while(USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET);</code></pre><p><font color="#dd0000"><strong>11、对于TXE位与TC位的一些自己的理解：</strong></font><br /><br>1、清零TXE位总是通过对数据寄存器的写操作(CPU或DMA)来完成的，当TXE位已经被硬件置1它表明：<br>● 数据已经从TDR移送到移位寄存器，数据发送已经开始(发送移位寄存器正在一位一位向外传输数据)。<br>● TDR寄存器被清空。<br>● 下一个数据可以被写进USART_DR寄存器而不会覆盖先前的数据如果TXEIE位被设置，此标志将产生一个中断。<br>如果此时USART正在发送数据(发送移位寄存器正在一位一位向外传输数据)，对USART_DR寄存器的写操作把数据存进TDR寄存器，并在当前传输结束时把该数据复制进移位寄存器，也就是说移位寄存器里面的数据并不会被覆盖，所以我觉得只要你发送一帧数据等待TXE置1，就算是发送多帧数据时最后也不用等待TC&#x3D;1。<font color="#dd0000">也就是往USART_DR寄存器中写数据只有可能覆盖USART_DR原有的数据（TXE位没有为1就开始写），而不会影响到发送移位寄存器向外发射数据</font><br /></p><p>2、如果此时USART没有在发送数据，处于空闲状态，对USART_DR寄存器的写操作直接把数据放进移位寄存器，数据传输开始，TXE位立即被置起。</p><p>3、当一帧发送完成时(停止位发送后)并且设置了TXE位，TC位被置起(TC位为1)，如果USART_CR1寄存器中的TCIE位被置起时(TCIE位为1)，则会产生中断。</p><p>4、使用下列软件过程清除TC位：<br>&lt;1&gt;．读一次USART_SR寄存器；<br>&lt;2&gt;．写一次USART_DR寄存器。<br>TC位也可以通过软件对它写’0’来清除。此清零方式只推荐在多缓冲器通信模式下使用。<br><font color="#dd0000"><strong>12、对于整个发送过程中所使用到的寄存器、中断的一些理解：</strong></font><br /><br>1、void USART_Config(void)函数配置<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/3216a009a4a7a6ec11bc9d1110fefa4.png"/><br>2、发送数据<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/82c7399fa6576a64a4fbad3d83ff1fa.png"/></p><h4 id="2-3-3-2-接收器"><a href="#2-3-3-2-接收器" class="headerlink" title="2.3.3.2-接收器"></a>2.3.3.2-接收器</h4><p>如果将USART_CR1寄存器的RE位置1，使能USART接收，使得接收器在RX线开始搜索起始位。在确定到起始位后就根据RX线电平状态把数据存放在接收移位寄存器内。接收完成后就把接收移位寄存器数据移到RDR内，并把USART_SR寄存器的RXNE位置1，同时如果USART_CR2寄存器的RXNEIE置1的话可以产生中断。<br><strong>注意：USART的所有中断共用一个中断服务函数DEBUG_USART_IRQHandler();所以在该中断函数中要有对中断标志位进行相应的判断，从而得知对应的中断类型。</strong>  </p><p><strong>字符接收：</strong><br>● RXNE位被置1。它表明移位寄存器的内容被转移到RDR。换句话说，数据已经被接收并且可以被读出。<br>● 如果RXNEIE位被设置，产生中断。<br>● 在多缓冲器通信时，RXNE在每个字节接收后被置起，并由DMA对数据寄存器的读操作而清零。<br>● 在单缓冲器模式里，由软件读USART_DR寄存器完成对RXNE位清除,RXNE标志也可以通过对它写0来清除。RXNE位必须在下一字符接收结束前(接收移位寄存器接收满)被清零(要将数据读出)，以避免溢出错误(移位寄存器的数据会被覆盖)。</p><p><strong>溢出错误：</strong><br>如果RXNE还没有被复位（还没有读出DR寄存器的数据），又接收到一个字符，则发生溢出错误,数据只有当RXNE位被清零后才能从移位寄存器转移到RDR寄存器。RXNE标记是接收到每个字节后被置位的。如果下一个数据已被收到或先前DMA请求还没被服务时，RXNE标志仍是1，溢出错误产生。  </p><p><strong>溢出错误：</strong><br>● ORE位被置位。<br>● RDR内容将不会丢失。读USART_DR寄存器仍能得到先前的数据。<br>● 移位寄存器中以前的内容将被覆盖。随后接收到的数据都将丢失。<br>● 如果RXNEIE位被设置或EIE和DMAR位都被设置，中断产生。<br>● 顺序执行对USART_SR和USART_DR寄存器的读操作，可复位ORE位。<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/862ae16a75795c1caccea3e91cafd25.png"/></p><h4 id="2-3-3-3-USART相关中断："><a href="#2-3-3-3-USART相关中断：" class="headerlink" title="2.3.3.3-USART相关中断："></a>2.3.3.3-USART相关中断：</h4><p>●发送期间：发送完成、清除发送、发送数据寄存器空。<br>●接收期间：空闲总线检测、溢出错误、接收数据寄存器非空、校验错误、 LIN断开符号检测、噪音标志(仅在多缓冲器通信)和帧错误(仅在多缓冲器通信)。<br>如果设置了对应的使能控制位，这些事件就可以产生各自的中断。<br><strong>USART中断映像图</strong><br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/577a3b93c0ad2e715862fa41cdc7a69.png" style="zoom: 50%;"/><br><strong>USART中断请求</strong><br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/ffa2797aa879fc7d5d48aee97528169.png" style="zoom: 75%;"/></p><h3 id="2-3-4-发送一个字节函数"><a href="#2-3-4-发送一个字节函数" class="headerlink" title="2.3.4-发送一个字节函数"></a>2.3.4-发送一个字节函数</h3><p>USART_SendData()函数本质是将要发送的数据写入发送数据寄存器中去，判断数据是否全部从发送数据寄存器转到发送移位寄存中去。全部转移返回值为1，则跳出while语句，未全部转移返回值为0，则一直执行while语句。<br>        &#x2F;&#x2F;全部转移返回值为1，则跳出while语句<br>        &#x2F;&#x2F;未全部转移返回值为0，则一直执行while语句</p><pre><code>//发送一个字节void Usart_SendByte(USART_TypeDef * pUSARTx,uint8_t date)&#123;    //USART_SendData()函数本质是将要发送的数据写入发送数据寄存器中去     USART_SendData(pUSARTx,date);     while( USART_GetFlagStatus(pUSARTx,USART_FLAG_TXE)== RESET);&#125;</code></pre><h3 id="2-3-5-发送16位数据"><a href="#2-3-5-发送16位数据" class="headerlink" title="2.3.5-发送16位数据"></a>2.3.5-发送16位数据</h3><pre><code>void Usart_SendHalfWord(USART_TypeDef * pUSARTx,uint16_t date)&#123;    uint16_t tmp_h;    uint16_t tmp_l;    //取出高8位    tmp_h =date&gt;&gt;0x08;    //取出低8位    tmp_l =date &amp; 0xff;    //发送高8位数据    Usart_SendByte(pUSARTx,tmp_h);    //等待数据全部转移到移位寄存器    while( USART_GetFlagStatus(pUSARTx,USART_FLAG_TXE)== RESET);    //发送低8位数据    Usart_SendByte(pUSARTx,tmp_l);    //等待数据全部转移到移位寄存器    while( USART_GetFlagStatus(pUSARTx,USART_FLAG_TXE)== RESET);&#125;</code></pre><h3 id="2-3-6-发送8位数组"><a href="#2-3-6-发送8位数组" class="headerlink" title="2.3.6-发送8位数组"></a>2.3.6-发送8位数组</h3><pre><code>//发送一个8位的数组void Usart_SendArray(USART_TypeDef * pUSARTx,uint8_t *arr,uint16_t num)&#123;    while(num--)     &#123;         Usart_SendByte( pUSARTx ,*arr++);//确定数据全部转移到移位寄存器中         while( USART_GetFlagStatus(pUSARTx,USART_FLAG_TXE)== RESET);     &#125;//确定数据全部从移位寄存器发送出去 while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TC)== RESET);&#125;</code></pre><h3 id="2-3-7-发送字符串"><a href="#2-3-7-发送字符串" class="headerlink" title="2.3.7-发送字符串"></a>2.3.7-发送字符串</h3><pre><code>//发送字符串void Usart_SendString( USART_TypeDef * pUSARTx, char *str)&#123; while( *str!=&#39;\0&#39; ) &#123;     Usart_SendByte( pUSARTx, *str++);      while( USART_GetFlagStatus(pUSARTx,USART_FLAG_TXE)== RESET); &#125; while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TC)== RESET);&#125;</code></pre><h2 id="2-4-重定向函数"><a href="#2-4-重定向函数" class="headerlink" title="2.4-重定向函数"></a>2.4-重定向函数</h2><p>在C语言标准库中，fputc函数是printf函数内部的一个函数，功能是将字符ch写入到文件指针f所指向文件的当前写指针位置，简单理解就是把字符写入到特定文件中。我们使用USART函数重新修改fputc函数内容，达到类似“写入”的功能。<br>fgetc函数与fputc函数非常相似，实现字符读取功能。在使用scanf函数时需要注意字符输入格式。<br>还有一点需要注意的，使用fput和fgetc函数达到重定向C语言标准库输入输出函数必须在MDK的工程选项把“Use MicroLIB”勾选上，MicoroLIB是缺省C库的备选库，它对标准C库进行了高度优化使代码更少，占用更少资源。<br>用户能定义自己的C语言库函数，连接器在连接时自动使用这些新的功能函数。这个过程叫做重定向C语言库函数。举例来说，用户有一个I&#x2F;O设备(如UART)。本来库函数fputc()是把字符输出到调试器控制窗口中去的，但用户把输出设备改成了UART端口，这样一来，所有基于fputc()函数的printf()系列函数输出都被重定向到UART端口上去了。<br>该函数写在bsp_usart.c文件中，且不需要在bsp_usart.h文件中声明。</p><pre><code>///重定向c库函数printf到串口，重定向后可使用printf函数int fputc(int ch, FILE *f)&#123;        /* 发送一个字节数据到串口 */        USART_SendData(DEBUG_USARTx, (uint8_t) ch);                /* 等待发送完毕 */        while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);            return (ch);&#125;///重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数int fgetc(FILE *f)&#123;        /* 等待串口输入数据 */        while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET);        return (int)USART_ReceiveData(DEBUG_USARTx);&#125;</code></pre><h2 id="2-5-中断服务函数"><a href="#2-5-中断服务函数" class="headerlink" title="2.5-中断服务函数"></a>2.5-中断服务函数</h2><p>因为所有的USART中断都使用同一个中断服务函数，所以在中断服务函数内要有判断中断类型的语句。该函数写在bsp_usart.c文件中，且不需要在bsp_usart.h文件中声明。</p><pre><code>void DEBUG_USART_IRQHandler(void)&#123;     uint16_t tmp;//判断产生的USART中断是属于接收信息中断if(USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) != RESET)    &#123;//接收输入的信息      tmp=USART_ReceiveData(DEBUG_USARTx);//把接收的信息立即发送出去      USART_SendData(DEBUG_USARTx,tmp);//等待数据发送完成while( USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE)== RESET);    &#125;&#125;</code></pre><p>利用中断服务函数控制LED灯的亮灭，注意发送时默认以字符形式发送，比如你发送的是1，但实际上它收到的是1再ASCII码中的序号49。故应勾选以16进制发送。</p><pre><code>void DEBUG_USART_IRQHandler(void)&#123;    uint16_t tmp; //判断中断类型    if(USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) != RESET)    &#123;        tmp=USART_ReceiveData(DEBUG_USARTx);//将单片机收到的数值发送给计算机        USART_SendData(DEBUG_USARTx,tmp);        while( USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE)== RESET);//判断收到的命令，并控制相应的LED灯亮灭        switch (tmp)        &#123;            case 1:                 LED_R_ON_OFF(ON);                printf(&quot;%d\n&quot;,tmp);                break;            case 2:                 LED_G_ON_OFF(ON);                printf(&quot;%d\n&quot;,tmp);                break;            case 3:                 LED_B_ON_OFF(ON);                printf(&quot;%d\n&quot;,tmp);                break;            default:                printf(&quot;输入错误，请重新输入\n&quot;);        &#125;    &#125;&#125;</code></pre>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</category>
      
      
      
      <comments>http://example.com/2023/03/07/STM32%E9%80%9A%E4%BF%A1%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>STM32定时器</title>
      <link>http://example.com/2023/03/05/STM32%E5%AE%9A%E6%97%B6%E5%99%A8/</link>
      <guid>http://example.com/2023/03/05/STM32%E5%AE%9A%E6%97%B6%E5%99%A8/</guid>
      <pubDate>Sun, 05 Mar 2023 03:01:59 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-0-STM32中断的分类&quot;&gt;&lt;a href=&quot;#1-0-STM32中断的分类&quot; class=&quot;headerlink&quot; title=&quot;1.0-STM32中断的分类&quot;&gt;&lt;/a&gt;1.0-STM32中断的分类&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://blog</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-0-STM32中断的分类"><a href="#1-0-STM32中断的分类" class="headerlink" title="1.0-STM32中断的分类"></a>1.0-STM32中断的分类</h1><p><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/cd437d820960af95c81bb3af04652bb.png"></p><h1 id="2-0-SysTick定时器"><a href="#2-0-SysTick定时器" class="headerlink" title="2.0-SysTick定时器"></a>2.0-SysTick定时器</h1><h2 id="2-1-SysTick定时器概念及工作原理"><a href="#2-1-SysTick定时器概念及工作原理" class="headerlink" title="2.1-SysTick定时器概念及工作原理"></a>2.1-SysTick定时器概念及工作原理</h2><p><strong>SysTick定时器概念：</strong>SysTick定时器(又名系统滴答定时器)是存在于Cortex-M3的一个定时器，只要是ARM Cotex-M系列内核的MCU都包含这个定时器。使用内核的SysTick定时器来实现延时，可以不占用系统定时器，节约资源。由于SysTick是在CPU核内部实现的，跟MCU外设无关，因此它的代码可以在不同厂家之间移植，因为ST这类厂商都是使用的ARM公司设计的内核，所以虽然外设各有不同，但是内核都是一样的，那么存在于内核的SysTick定时器的相关代码自然可以相互移植。<br><strong>工作原理：</strong>SysTick定时器是一个24位递减定时器，即计数器可以从最大值$2^{24}$开始，每个时钟周期减1，当减到0时，会产生Systick异常，同时再自动重载定时初值，开始新一轮计数。通过设置这个定时初值，就可以实现得到指定时间。  </p><h2 id="2-2-计时时间计算"><a href="#2-2-计时时间计算" class="headerlink" title="2.2-计时时间计算"></a>2.2-计时时间计算</h2><p><strong>t：</strong>一个计数循环时间，跟reload(重装载值)和CLK(系统时钟)有关。<br><strong>CLK：</strong>72M或者9M，由CTRL寄存器配置。<br>*<em>RELOAD:<em><em>24位，用户自己设置，范围为0~$2^{24}$<br>t&#x3D;reload</em>(1&#x2F;CLK)<br>CLK&#x3D;72M时，t&#x3D;72</em>(1&#x2F;72M)&#x3D;1us<br>CLK&#x3D;72M时，t&#x3D;72000</em>(1&#x2F;72M)&#x3D;1ms<br><strong>时间单位换算：</strong><br>1s&#x3D;1000ms&#x3D;1000 000us&#x3D;1000 000 000nm  </p><h2 id="2-3-SysTick定时器的寄存器"><a href="#2-3-SysTick定时器的寄存器" class="headerlink" title="2.3-SysTick定时器的寄存器"></a>2.3-SysTick定时器的寄存器</h2><p>SysTick—系统定时器有4个寄存器，简要介绍如下。在使用SysTick产生定时的时候，只需要配置前三个寄存器，最后一个校准寄存器不需要使用。在core_cm3.h文件中将所涉及到的寄存器包装成一个结构体。</p><pre><code>typedef struct&#123;  __IO uint32_t CTRL;      /*!&lt; Offset: 0x00  SysTick Control and Status Register */控制及状态寄存器  __IO uint32_t LOAD;      /*!&lt; Offset: 0x04  SysTick Reload Value Register       */重装载数值寄存器  __IO uint32_t VAL;       /*!&lt; Offset: 0x08  SysTick Current Value Register      */当前数值寄存器  __I  uint32_t CALIB;     /*!&lt; Offset: 0x0C  SysTick Calibration Register        */校准寄存器&#125; SysTick_Type;</code></pre><h3 id="2-3-1-系统滴答定时器控制和状态寄存器（STK-CTRL）"><a href="#2-3-1-系统滴答定时器控制和状态寄存器（STK-CTRL）" class="headerlink" title="2.3.1 系统滴答定时器控制和状态寄存器（STK_CTRL）"></a>2.3.1 系统滴答定时器控制和状态寄存器（STK_CTRL）</h3><p>重点关注Bit[0]，用于使能系统滴答定时器，Bit[1]使能系统滴答定时器中断，Bit[2]系统滴答时钟的时钟来源。<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E5%92%8C%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88STK_CTRL%EF%BC%89.png"></p><h3 id="2-3-2-系统滴答定时器加载值寄存器（STK-LOAD）"><a href="#2-3-2-系统滴答定时器加载值寄存器（STK-LOAD）" class="headerlink" title="2.3.2-系统滴答定时器加载值寄存器（STK_LOAD）"></a>2.3.2-系统滴答定时器加载值寄存器（STK_LOAD）</h3><p>Bit[23:0]，一共24位，用来设置系统滴答定时器的初始值，因此范围为1~ 16777216<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8A%A0%E8%BD%BD%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88STK_LOAD%EF%BC%89.png"></p><h3 id="2-3-3-系统滴答定时器当前值寄存器（STK-VAL）"><a href="#2-3-3-系统滴答定时器当前值寄存器（STK-VAL）" class="headerlink" title="2.3.3-系统滴答定时器当前值寄存器（STK_VAL）"></a>2.3.3-系统滴答定时器当前值寄存器（STK_VAL）</h3><p>Bit[23:0]，一共24位，用来获取当前系统滴答定时器的计数值。<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BD%93%E5%89%8D%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88STK_VAL%EF%BC%89.png"></p><h3 id="2-3-4-系统滴答定时器校准值寄存器（STK-CALIB）"><a href="#2-3-4-系统滴答定时器校准值寄存器（STK-CALIB）" class="headerlink" title="2.3.4-系统滴答定时器校准值寄存器（STK_CALIB）"></a>2.3.4-系统滴答定时器校准值寄存器（STK_CALIB）</h3><p>这个寄存器没用到，可以不用管。此外，当处理器在调试期间被暂停（halt）时，系统滴答定时器也将暂停运作。<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A0%A1%E5%87%86%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88STK_CALIB%EF%BC%89.png"></p><h2 id="2-4-系统滴答定时器配置函数"><a href="#2-4-系统滴答定时器配置函数" class="headerlink" title="2.4-系统滴答定时器配置函数"></a>2.4-系统滴答定时器配置函数</h2><p>在core_cm3.h文件中已经定义好了系统滴答定时器配置函数，我们在编写延时函数时直接调用就行，现在分析一下这个配置函数。</p><pre><code>static __INLINE uint32_t SysTick_Config(uint32_t ticks)   &#123; //判断输入的ticks是否超过$2^&#123;24&#125;$  if (ticks &gt; SysTick_LOAD_RELOAD_Msk)  return (1);            //配置reload寄存器的初始值                                                                SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - 1;//配置中断优先级为 1&lt;&lt;4-1=15,优先级最低        NVIC_SetPriority (SysTick_IRQn, (1&lt;&lt;__NVIC_PRIO_BITS) - 1); //配置counter 计数器的值  SysTick-&gt;VAL   = 0;   //配置systick的时钟为72M//使能中断//使能systick                                         SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk |                    SysTick_CTRL_TICKINT_Msk   |                    SysTick_CTRL_ENABLE_Msk;                    return (0);                                                 &#125;</code></pre><p><strong>static的作用是什么？：</strong><br>在函数的返回类型前加上关键字static，函数就被定义成为静态函数。函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。定义静态函数的好处：<br>&lt;1&gt; 其他文件中可以定义相同名字的函数，不会发生冲突<br>&lt;2&gt; 静态函数不能被其他文件所用。<br><strong>ul是什么意思？</strong><br>SysTick_LOAD_RELOAD_Msk在core_cm3.h文件中是如下定义的</p><pre><code>#define SysTick_LOAD_RELOAD_Pos    0                                           /*!&lt; SysTick LOAD: RELOAD Position */#define SysTick_LOAD_RELOAD_Msk    (0xFFFFFFul &lt;&lt; SysTick_LOAD_RELOAD_Pos)     /*!&lt; SysTick LOAD: RELOAD Mask */</code></pre><p>注意这里的表示常量类型的方法，就是放后面的；定义变量放前面。“u”表示“unsigned”，无符号“l”表示“long”，长整型。如果不加UL的话那就是默认的int型，ul后缀.也是一种强制转换方式。<br><strong>为什么要用两次宏定义来完成寄存器某几位的赋值？</strong><br>我们以”SysTick_CTRL_CLKSOURCE_Msk”为例，找到它对应的宏定义：</p><pre><code>#define SysTick_CTRL_CLKSOURCE_Pos          2                                          #define SysTick_CTRL_CLKSOURCE_Msk         (1ul &lt;&lt; SysTick_CTRL_CLKSOURCE_Pos)   </code></pre><p>这里的”SysTick_CTRL_CLKSOURCE_Pos “ 表示的是CLKSOURCE在SysTick的CTRL寄存器中的位置，第2位。然后我们把要写入的值1（目的是采用AHB的72M时钟源）左移相应的2位（CLKSOURCE在CTRL寄存器中的位置）。这样做的好处就是方便我们在给CTRL寄存器写值的时候能恰好写在对应的位数上而不改变其他位数的值，这也就是后面为什么会连续两个按位或”|” 。<br><strong>为什么配置reload寄存器的初始值要减一？</strong><br>因为将重装载值写入reload也需要一个时间，所以减一。<br><strong>注意：</strong><br>这里使用了中断源SysTick_IRQn，所以必须包含头文件stm32f10x.h。</p><h2 id="2-5-微秒-x2F-毫秒级延时函数-未使用中断函数"><a href="#2-5-微秒-x2F-毫秒级延时函数-未使用中断函数" class="headerlink" title="2.5-微秒&#x2F;毫秒级延时函数(未使用中断函数)"></a>2.5-微秒&#x2F;毫秒级延时函数(未使用中断函数)</h2><p>couter 减1的时间 等于 1&#x2F;systick_clk，当counter 从 reload 的值减小到0的时候，为一个循环，如果开启了中断则执行中断服务程序，同时 CTRL 的 countflag 位会置1，这一个循环的时间为 reload * (1&#x2F;systick_clk)<br><strong>微秒级延时函数：</strong>  </p><pre><code>void SysTick_Delay_Us( __IO uint32_t us)&#123;    uint32_t i;    SysTick_Config(SystemCoreClock/1000000);        for(i=0;i&lt;us;i++)    &#123;// 当计数器的值减小到0的时候，CRTL寄存器的第16位会置1,否1就是0，//此时跳出while循环，for语句中i＋1，进入下一个计数周期        while( !((SysTick-&gt;CTRL)&amp;(1&lt;&lt;16)) );    &#125;    // 关闭SysTick定时器    SysTick-&gt;CTRL &amp;=~SysTick_CTRL_ENABLE_Msk;&#125; </code></pre><p><strong>毫秒级延时函数：</strong></p><pre><code>void SysTick_Delay_Us( __IO uint32_t ms)&#123;    uint32_t i;    SysTick_Config(SystemCoreClock/1000);        for(i=0;i&lt;ms;i++)    &#123;        // 当计数器的值减小到0的时候，CRTL寄存器的位16会置1        while( !((SysTick-&gt;CTRL)&amp;(1&lt;&lt;16)) );    &#125;    // 关闭SysTick定时器    //这里的&quot;&amp;=&quot;之间不能有空格，&quot;&amp; =&quot;这种写法是错误的    SysTick-&gt;CTRL &amp;=~SysTick_CTRL_ENABLE_Msk;&#125;</code></pre><p><strong>注意：</strong><br><strong>&lt;1&gt;</strong>  stm32f10x.h文件要在core_cm3.h文件之前包含，即如下顺序：</p><pre><code>#include &quot;stm32f10x.h&quot; #include &quot;core_cm3.h&quot;</code></pre><h2 id="2-6-微秒-x2F-毫秒级延时函数-使用中断服务函数"><a href="#2-6-微秒-x2F-毫秒级延时函数-使用中断服务函数" class="headerlink" title="2.6-微秒&#x2F;毫秒级延时函数(使用中断服务函数)"></a>2.6-微秒&#x2F;毫秒级延时函数(使用中断服务函数)</h2><p><strong>毫秒级延时函数：</strong><br>1、先在bsp_systick.c文件中定义一个全局变量（在函数体外部、文件顶部定义），如下：</p><pre><code>uint32_t global_ms;</code></pre><p>2、在bsp_systick.c定义延时函数，如下：</p><pre><code>void Delay_Interrupt__ms(uint32_t ms)&#123;    SysTick_Config(72000);    global_ms=ms;    while(global_ms!=0);&#125;</code></pre><p>3、在stm32f10x_it.c文件头部、终端服务函数外部引用全局变量：</p><pre><code>extern uint32_t global_ms;//定义的全局变量秒数</code></pre><p>4、在stm32f10x_it.c文件中编写中断服务函数：</p><pre><code>void SysTick_Handler(void)&#123;    if(global_ms)    &#123;        global_ms--;    &#125;&#125;</code></pre><p><strong>注意：</strong><br>1、也可将中断服务函数写在bsp_systick.c,则此时无需语句”extern uint32_t global_ms;”,只需将变量定义在函数体外即可默认为全局变量。<br>2、在终端服务函数中无需再配置滴答计时器SysTick_Config()，因为它是自动重装。<br>3、微秒级延时函数同理不再赘述。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</category>
      
      
      
      <comments>http://example.com/2023/03/05/STM32%E5%AE%9A%E6%97%B6%E5%99%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>中断</title>
      <link>http://example.com/2023/03/03/%E4%B8%AD%E6%96%AD/</link>
      <guid>http://example.com/2023/03/03/%E4%B8%AD%E6%96%AD/</guid>
      <pubDate>Fri, 03 Mar 2023 07:31:39 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-0-中断&quot;&gt;&lt;a href=&quot;#1-0-中断&quot; class=&quot;headerlink&quot; title=&quot;1.0-中断&quot;&gt;&lt;/a&gt;1.0-中断&lt;/h1&gt;&lt;h2 id=&quot;1-1-中断概念&quot;&gt;&lt;a href=&quot;#1-1-中断概念&quot; class=&quot;headerlink&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-0-中断"><a href="#1-0-中断" class="headerlink" title="1.0-中断"></a>1.0-中断</h1><h2 id="1-1-中断概念"><a href="#1-1-中断概念" class="headerlink" title="1.1-中断概念"></a>1.1-中断概念</h2><p>打断cpu正常执行程序，转而处理紧急程序，然后返回原暂停的程序继续运行，就叫做中断。</p><h2 id="1-2-中断的作用和意义"><a href="#1-2-中断的作用和意义" class="headerlink" title="1.2-中断的作用和意义"></a>1.2-中断的作用和意义</h2><p>1、实时控制：在确定时间内对相应事件做出相应，如：温度控制。可以设置定时器，在设置的时间间隔读取温度，设置的时间越短，则实时性越高。<br>2、故障处理：检测到故障，需要第一时间停下当前执行的程序而去处理故障，故障处理完毕再回到原来的程序停止处继续执行。<br>3、数据传输：不确定数据何时会传来，不能占用CPU空转一直等待数据传输过来，而是当数据传输过来时设置中断。如：串口数据接收。<br>4、中断的意义：高效处理紧急程序，并不会一直占用CPU资源。</p><h2 id="STM32-GPIO外部中断简图"><a href="#STM32-GPIO外部中断简图" class="headerlink" title="STM32 GPIO外部中断简图"></a>STM32 GPIO外部中断简图</h2><p><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/01ae2009aeab7f2ae8dcc8a98bb23f9.png"></p><h1 id="2-0-NVIC"><a href="#2-0-NVIC" class="headerlink" title="2.0-NVIC"></a>2.0-NVIC</h1><h2 id="2-1-NVIC的基本概念"><a href="#2-1-NVIC的基本概念" class="headerlink" title="2.1-NVIC的基本概念"></a>2.1-NVIC的基本概念</h2><p>Nested vectored interrupt controller,嵌套向量中断控制器，属于内核(M3&#x2F;4&#x2F;7)。NVIC支持：256个中断（16内核+240外部），支持：256个优先级，允许剪裁。每个中断都对应一个中断服务函数，中断服务函数是用来处理中断的，中断服务函数的名称不能任意起名，它存在于中断向量列表中，startup_stm32f10x_hd.s(启动文件)上有相应的定义。它是一种弱定义，也就是在.c文件中有同样中断函数名的定义，则执行.c文件中的函数，若.c文件中没有相应的函数名定义或者定义错误，则中断发生时，执行这个.s文件的中断服务函数。<br>中断向量表：定义一块固定的内存，以4字节对齐，存放各个中断服务函数的首地址，中断向量表定义在启动文件中，当中断发生时，CPU会自动执行对应的中断服务函数。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/63a40802034218baec7a676423c23c3.png"></p><h2 id="2-2-NVIC相关寄存器介绍"><a href="#2-2-NVIC相关寄存器介绍" class="headerlink" title="2.2-NVIC相关寄存器介绍"></a>2.2-NVIC相关寄存器介绍</h2><table><thead><tr><th align="center">NVIC相关寄存器</th><th align="center">位数</th><th align="center">寄存器个数</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">中断使能寄存器(ISER)</td><td align="center">32</td><td align="center">8</td><td align="center">每一位控制一个中断</td></tr><tr><td align="center">中断除能寄存器(ICRE)</td><td align="center">32</td><td align="center">8</td><td align="center">每一位控制一个中断</td></tr><tr><td align="center">应用程序中断及复位控制寄存器(AIRCR)</td><td align="center">32</td><td align="center">1</td><td align="center">位[10:8]控制优先级分组</td></tr><tr><td align="center">中断优先级寄存器(IPR)</td><td align="center">8</td><td align="center">240</td><td align="center">8个位对应一个中断，而STM32只使用高4位</td></tr></tbody></table><p>除此之外，NVIC还有其他的功能如：中断挂起、解挂、激活标志等非常用功能。</p><h2 id="2-3-NVIC工作原理"><a href="#2-3-NVIC工作原理" class="headerlink" title="2.3-NVIC工作原理"></a>2.3-NVIC工作原理</h2><p><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/9470095f2fbb1c67c149dcc71ab8448.png"></p><h2 id="2-4-STM32中断优先级基本概念"><a href="#2-4-STM32中断优先级基本概念" class="headerlink" title="2.4-STM32中断优先级基本概念"></a>2.4-STM32中断优先级基本概念</h2><p>1、抢占优先级(pre):高抢占优先级可以打断正在执行的低抢占优先级中断（嵌套），数字越低优先级越高。<br>2、相应优先级(sub):当抢占优先级相同时，响应优先级高的先执行，但不能相互打断。<br>3、自然优先级：抢占和响应优先级都相同的情况下，自然优先级越高的越先执行。自然优先级指的是在中断向量表里的优先级。自然优先级可以在stm32f10x.h文件里有枚举类型IRQn_Type中查询到。</p><h2 id="2-5-中断优先级分组"><a href="#2-5-中断优先级分组" class="headerlink" title="2.5-中断优先级分组"></a>2.5-中断优先级分组</h2><table><thead><tr><th align="center">优先级分组</th><th align="center">AIRCR[10:8]</th><th align="center">IPRx bit[7:4]分配</th><th align="center">分配结果</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">111</td><td align="center">None:[7:4]</td><td align="center">0位抢占优先级（可配置0级），4位响应优先级（可配置16级）</td></tr><tr><td align="center">1</td><td align="center">110</td><td align="center">[7]:[6:4]</td><td align="center">1位抢占优先级（可配置2级），3位响应优先级（可配置8级）</td></tr><tr><td align="center">2</td><td align="center">101</td><td align="center">[7:6]:[5:4]</td><td align="center">2位抢断优先级（可配置4级），2位响应优先级（可配置4级）</td></tr><tr><td align="center">3</td><td align="center">100</td><td align="center">[7:5]:[4]</td><td align="center">3位抢断优先级（可配置8级），1位响应优先级（可配置1级）</td></tr><tr><td align="center">4</td><td align="center">011</td><td align="center">[7:4]:None</td><td align="center">4位抢断优先级（可配置16级），0位响应优先级（可配置0级）</td></tr></tbody></table><p><font color="#dd0000">特别提示：一个工程中，一般只设置一次中断优先级分组</font><br />   </p><h2 id="2-6-NVIC的使用"><a href="#2-6-NVIC的使用" class="headerlink" title="2.6-NVIC的使用"></a>2.6-NVIC的使用</h2><p>在创建NVIC配置函数时，使用static关键字，意味着这个函数只能被和此函数同在一个头文件中的函数调用。NVIC与EXTI一样自动开启时钟，不需要手动开启时钟。</p><pre><code>static void EXTI_NVIC_Config(void)&#123;&#125;</code></pre><p><strong>1、创建一个NVIC_InitTypeDef结构体：</strong></p><pre><code> NVIC_InitTypeDef NVIC_InitStructure;</code></pre><p><strong>2、设置分组：</strong>使用misc.h文件中的初始化函数 NVIC_PriorityGroupConfig()进行分组。  </p><pre><code>void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);</code></pre><p><strong>3、配置NVIC结构体参数：</strong>在misc.h文件前部有关于NVIC结构体的定义。</p><pre><code>  typedef struct&#123;  uint8_t NVIC_IRQChannel;                    /*!&lt; Specifies the IRQ channel to be enabled or disabled.                                                   This parameter can be a value of @ref IRQn_Type                                                    (For the complete STM32 Devices IRQ Channels list, please                                                    refer to stm32f10x.h file) */选择中断源  uint8_t NVIC_IRQChannelPreemptionPriority;  /*!&lt; Specifies the pre-emption priority for the IRQ channel                                                   specified in NVIC_IRQChannel. This parameter can be a value                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */配置该中断源的抢断优先级  uint8_t NVIC_IRQChannelSubPriority;         /*!&lt; Specifies the subpriority level for the IRQ channel specified                                                   in NVIC_IRQChannel. This parameter can be a value                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */配置该中断源的响应优先级  FunctionalState NVIC_IRQChannelCmd;         /*!&lt; Specifies whether the IRQ channel defined in NVIC_IRQChannel                                                   will be enabled or disabled.                                                    This parameter can be set either to ENABLE or DISABLE */ 配置使能位，也就是中断总开关的打开/关闭  &#125; NVIC_InitTypeDef;</code></pre><p>我们创建一个关于NVIC的结构体后就可以往里面写入配置参数。这里要注意的是中断源的选择在stm32f10x.h文件中有枚举类型IRQn_Type，从中选择就行，还要注意的是：</p><pre><code>  EXTI0_IRQn                  = 6,      /*!&lt; EXTI Line0 Interrupt                                 */  EXTI1_IRQn                  = 7,      /*!&lt; EXTI Line1 Interrupt                                 */  EXTI2_IRQn                  = 8,      /*!&lt; EXTI Line2 Interrupt                                 */  EXTI3_IRQn                  = 9,      /*!&lt; EXTI Line3 Interrupt                                 */  EXTI4_IRQn                  = 10,     /*!&lt; EXTI Line4 Interrupt                                 */  EXTI9_5_IRQn                = 23,     /*!&lt; External Line[9:5] Interrupts                        */  EXTI15_10_IRQn              = 40,     /*!&lt; External Line[15:10] Interrupts                      */</code></pre><p><font color="#dd0000">这里GPIO的5-9引脚共用一个中断源、10-15引脚共用一个中断源</font><br /><br><font color="#dd0000">4、初始化NVIC结构体：</font><br />其本质就是利用函数NVIC_Init()将配置好的NVIC结构体参数写入响应的寄存器中去。该函数定义在misc.h文件中。</p><pre><code>void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);  </code></pre><h1 id="3-0-EXTI"><a href="#3-0-EXTI" class="headerlink" title="3.0-EXTI"></a>3.0-EXTI</h1><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1-基本概念"></a>3.1-基本概念</h2><p>External(Extended)interrupt&#x2F;even Controller,外部(扩展)中断事件控制器。其包含20个产生时间&#x2F;中断请求的边缘检测器，即总共20条EXTI线(F1)，其中EXTI线0<del>15对应GPIO PIN0</del>15、EXTI线16对应PVD输出、EXTI线17对应PTC闹钟事件、EXTI线18对应USB OTG FS唤醒事件、EXTI线19对应以太网唤醒事件（仅互联型有，基础型无）</p><table><thead><tr><th align="center">线数</th><th align="center">对应功能</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">EXTI线0~15</td><td align="center">GPIO PIN0~15</td><td align="center">无</td></tr><tr><td align="center">EXTI线16</td><td align="center">PVD输出</td><td align="center">无</td></tr><tr><td align="center">EXTI线17</td><td align="center">PTC闹钟事件</td><td align="center">无</td></tr><tr><td align="center">EXTI线18</td><td align="center">USB OTG FS唤醒事件</td><td align="center">无</td></tr><tr><td align="center">EXTI线19</td><td align="center">以太网唤醒事件</td><td align="center">仅互联型有，基础型无</td></tr></tbody></table><p>中断：要进入NVIC,有相应的中断服务函数，需要CPU处理。<br>事件:不进入nvic,仅用内部硬件自动控制的，如：TIM、DMA、ADC。  </p><h2 id="3-2-EXTI主要特性"><a href="#3-2-EXTI主要特性" class="headerlink" title="3.2-EXTI主要特性"></a>3.2-EXTI主要特性</h2><p>F1&#x2F;F4&#x2F;F7系列：<br>每条EXTI线都可以单独配置：选择类型（中断或者事件类型）、触发方式（上升沿、下降沿或者双边沿触发）、支持软件触发、开启&#x2F;屏蔽、有挂起状态位。</p><h2 id="3-3-EXTI工作原理"><a href="#3-3-EXTI工作原理" class="headerlink" title="3.3-EXTI工作原理"></a>3.3-EXTI工作原理</h2><p><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/d7e9307d97c58e0d8fcc5037b62cfe6.png"><br>需要重点掌握的寄存器：<br><font color="#dd0000">上升沿触发选择寄存器(EXTI_RTSR)：</font><br />选择或禁止EXTI某条线上的上升沿触发方式<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/8560d9c63af3375b5b16e9521df47d4.png"><br><font color="#dd0000">上升沿触发选择寄存器(EXTI_RTSR)：</font><br />选择或禁止EXTI某条线上的上升沿触发方式<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/f4c10913e600036e6d3c69245cc11d0.png"><br><font color="#dd0000">中断屏蔽寄存器(EXTI_IMR)：</font><br />选择屏蔽EXTI某条线上的中断请求<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/07b4f4509c571d901d3ba1592d796d7.png"><br><font color="#dd0000">挂起寄存器(EXTI_PR)：</font><br />EXTI某条线发生中断，则EXTI_PR的对应位会由硬件置1。在中断处理函数中要清楚该位，写入1即可清除。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/e94cf2ded3c141db556dd66ad003f3c.png"></p><h2 id="3-4-EXTI和IO的映射关系"><a href="#3-4-EXTI和IO的映射关系" class="headerlink" title="3.4-EXTI和IO的映射关系"></a>3.4-EXTI和IO的映射关系</h2><h3 id="3-4-1-AFIO简介"><a href="#3-4-1-AFIO简介" class="headerlink" title="3.4.1-AFIO简介"></a>3.4.1-AFIO简介</h3><p>Alternate FUnction IO,即复用功能IO，主要用于重映射和外部中断源映射配置。<br>1、调试IO配置：AFIO_MARR[26:24],配置JTAG&#x2F;SWD的开关状态。<br>2、重映射配置：AFIO_MARR，部分外设IO口重映射配置。<br>3、外部中断配置：AFIO_EXTICR1~4，配置EXTI中断线对应到哪个具体IO口。<br><font color="#dd0000">特别注意：</font><br />配置AFIO寄存器之前要使能AFIO时钟，用stm32f1ox_rcc.h文件中的函数</p><pre><code>void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);</code></pre><h3 id="3-4-2-EXTI与IO对应关系"><a href="#3-4-2-EXTI与IO对应关系" class="headerlink" title="3.4.2-EXTI与IO对应关系"></a>3.4.2-EXTI与IO对应关系</h3><p>查阅STM32中文参考手册，AFIO有4个外部中断配置寄存器(AFIO_EXTICR1、AFIO_EXTICR2、AFIO_EXTICR3、AFIO_EXTICR4)，它们的低16位有效，每4位配置EXTI的某条线(0<del>15),这四位的数值又可以配GPIO置具体端口(A</del>G)。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/a2aae20fe5b35eea1e6d7c3639b0827.png"><br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/880e6df44ae14c276001379489501fd.png"></p><h2 id="3-5-EXTI的使用"><a href="#3-5-EXTI的使用" class="headerlink" title="3.5-EXTI的使用"></a>3.5-EXTI的使用</h2><p><strong>1、创建一个EXTI结构体：</strong>在stm32f10x_exti.h文件中有关于EXTI结构体的定义，结构体的创建要在函数的最前面创建。</p><pre><code>typedef struct&#123;  uint32_t EXTI_Line;               /*!&lt; Specifies the EXTI lines to be enabled or disabled.                                         This parameter can be any combination of @ref EXTI_Lines */     EXTIMode_TypeDef EXTI_Mode;       /*!&lt; Specifies the mode for the EXTI lines.                                         This parameter can be a value of @ref EXTIMode_TypeDef */  EXTITrigger_TypeDef EXTI_Trigger; /*!&lt; Specifies the trigger signal active edge for the EXTI lines.                                         This parameter can be a value of @ref EXTIMode_TypeDef */  FunctionalState EXTI_LineCmd;     /*!&lt; Specifies the new state of the selected EXTI lines.                                         This parameter can be set either to ENABLE or DISABLE */ &#125;EXTI_InitTypeDef;</code></pre><p><strong>2、开启时钟：</strong>查阅stm32中文手册中存储器与总线设置可知，AFIO与GPIOA都挂载在AHP2上。stm32f10x_rcc.h上有AHB2时钟开启函数,注意EXTI和NVIC的时钟是自动开启无需手动开启，这里开启的是AFIO的时钟。<br>    void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);<br><strong>3、选择输入信号源：</strong>这个函数中配置了AFIO中的EXTICR寄存器，用于EXTIx线的外部中断输入源。</p><pre><code>GPIO_EXTILineConfig(KEY1_INT_EXTI_PORTSOURCE, KEY1_INT_EXTI_PINSOURCE); </code></pre><p><strong>3、配置步骤一创建的EXTI结构体中的参数：</strong>相应的参数在stm32f10x_exti.h文件中都有枚举。这里的选择信号源指的是对中断信号源开启或者屏蔽，用于初始化EXTI-&gt;EMR或EXTI-&gt;IMR这两个寄存器。</p><pre><code>EXTI_InitStructure.EXTI_Line = EXTI_Line0;                /*选择信号源*/EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;       /*EXTI设置为中断模式*/EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;    /*上升沿触发中断*/EXTI_InitStructure.EXTI_LineCmd = ENABLE;                 /*中断使能*/</code></pre><p><strong>4、初始化结构体：</strong>本质是将第三步配置好的参数写入相应的寄存器中，只不过将这一步用库函数封装了。</p><pre><code>EXTI_Init(&amp;EXTI_InitStructure);</code></pre><h1 id="4-0-GPIO"><a href="#4-0-GPIO" class="headerlink" title="4.0-GPIO"></a>4.0-GPIO</h1><h2 id="4-1-GPIO的配置"><a href="#4-1-GPIO的配置" class="headerlink" title="4.1-GPIO的配置"></a>4.1-GPIO的配置</h2><p><strong>1、创建一GPIO结构体：</strong>在stm32f10x_gpio.h文件中有关于gpio结构体的定义。注意结构体成员中只有要配置的GPIO引脚(0到15)而没有要配置的GPIO端口。端口的参数(A到G)在GPIO初始化函数中调用。</p><pre><code>typedef struct&#123;  uint16_t GPIO_Pin;             /*!&lt; Specifies the GPIO pins to be configured.                                      This parameter can be any value of @ref GPIO_pins_define */选择  GPIOSpeed_TypeDef GPIO_Speed;  /*!&lt; Specifies the speed for the selected pins.                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */  GPIOMode_TypeDef GPIO_Mode;    /*!&lt; Specifies the operating mode for the selected pins.                                      This parameter can be a value of @ref GPIOMode_TypeDef */&#125;GPIO_InitTypeDef; </code></pre><p><strong>2、开启时钟：</strong> 每个外设都配备了外设时钟的开关，当我们不使用某个外设时，可以把这个外设时钟关闭，从而降低 STM32 的整体功耗。因此，在我们使用外设前，必须要开启相应外设的时钟。在stm32f10x_rcc.c文件中有时钟开启函数</p><pre><code>void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)  </code></pre><p><strong>3、配置结构体成员的参数</strong><br>引脚选用相应的引脚即可。<br>输入模式选用浮空输入：输入信号经过施密特触发器接入输入数据存储器。当无信号输入时，电压不确定。因为浮空输入既高阻输入，可以认为输入端口阻抗无穷大，这样可以检测到微弱的信号。（相当于电压表测电压，如果电压表内阻不够大而外部阻抗比较大，则电压表分压会比较小）。此时输入高电平即高电平，输入低电平即低电平。但是外界没有输入时输入电平却容易受到外界电磁以及各种玄学干扰的影响。如按键采用浮空输入，则在按键按下时输入电平为低，但是当松开按键时输入端口悬空，外界有微弱的干扰都会被端口检测到。此时端口可能高，也可能低。<br>因为是输入所以没有模式的配置，可以删除。<br>**4、初始化结构体:**利用函数初始化结构体，本质就是将配置的结构体成员参数写入相应的寄存器中去，这一步封装成了个函数。</p><pre><code>void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</code></pre><h1 id="5-0-中断服务函数"><a href="#5-0-中断服务函数" class="headerlink" title="5.0-中断服务函数"></a>5.0-中断服务函数</h1><p>中断服务函数定义在stm32f10x_it.c文件中，包括以下几个部分：<br><strong>1、中断服务函数名：</strong>中断服务函数名在启动文件startup_stm32f10x_hd.s中的中断向量表里，名称不能随意更改。中断发生后自动跳转到对应的中断服务函数中去。<br><strong>2、判断中断是否真发生：</strong>在stm32f10x_exti.h文件中调用函数如下，判断是否真实发生中断。  </p><pre><code>ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);</code></pre><p>其中的ITStarus是一个枚举类型的关键字</p><pre><code>typedef enum &#123;RESET = 0, SET = !RESET&#125; FlagStatus, ITStatus;  </code></pre><p><strong>3、清楚中断标志位：</strong>防止一直处于中断状态，调用stm32f10x_exti.c文件中的函数清除状态标志位。</p><pre><code>void EXTI_ClearITPendingBit(uint32_t EXTI_Line)&#123;  /* Check the parameters */  assert_param(IS_EXTI_LINE(EXTI_Line));    EXTI-&gt;PR = EXTI_Line;&#125;  </code></pre><h1 id="6-0-总结"><a href="#6-0-总结" class="headerlink" title="6.0-总结"></a>6.0-总结</h1><p>整个外部中断的配置思路是：GPIO的配置-&gt;EXTI的配置-&gt;NVIC的配置-&gt;CPU执行中断函数的配置</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</category>
      
      
      
      <comments>http://example.com/2023/03/03/%E4%B8%AD%E6%96%AD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>STM32时钟系统</title>
      <link>http://example.com/2023/02/28/STM32%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F/</link>
      <guid>http://example.com/2023/02/28/STM32%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F/</guid>
      <pubDate>Tue, 28 Feb 2023 14:03:45 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-0-STM32时钟系统框架&quot;&gt;&lt;a href=&quot;#1-0-STM32时钟系统框架&quot; class=&quot;headerlink&quot; title=&quot;1.0-STM32时钟系统框架&quot;&gt;&lt;/a&gt;1.0-STM32时钟系统框架&lt;/h1&gt;&lt;p&gt;STM32F10**的时钟系统框架图</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-0-STM32时钟系统框架"><a href="#1-0-STM32时钟系统框架" class="headerlink" title="1.0-STM32时钟系统框架"></a>1.0-STM32时钟系统框架</h1><p>STM32F10**的时钟系统框架图如下<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/81e55b22349974904817ec531ea5b0e.png"><br>其中的蓝色方框为时钟源，他们的功能如下<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/fd7fad480d1d3269f6c0ee5bfa8abc3.png"><br>灰色的等腰梯形是时钟源选择器，它可以选择多路时钟信号的其中一个来作为信号输出给下一器件，绿色方框是预分频器，用来分频。</p><h1 id="2-0-系统初始化函数运行过程"><a href="#2-0-系统初始化函数运行过程" class="headerlink" title="2.0-系统初始化函数运行过程"></a>2.0-系统初始化函数运行过程</h1><p>总的来说，整个文件、函数的调用顺序如下：<br>startup_stm32f10x_cl.s（启动文件） → SystemInit() →  SetSysClock () → SetSysClockTo72()</p><h2 id="2-1-startup-stm32f10x-cl-s（启动文件）"><a href="#2-1-startup-stm32f10x-cl-s（启动文件）" class="headerlink" title="2.1-startup_stm32f10x_cl.s（启动文件）"></a>2.1-startup_stm32f10x_cl.s（启动文件）</h2><p>在启动文件startup_stm32f10x_hd.s中调用系统初始化函数SystemInit </p><pre><code>Reset_Handler   PROCEXPORT  Reset_Handler             [WEAK]IMPORT  __mainIMPORT  SystemInitLDR     R0, =SystemInitBLX     R0               LDR     R0, =__mainBX      R0ENDP</code></pre><p>注意系统初始化函数在，主函数main之前就已经调用了，也就是说程序执行主函数内容之前，系统就已经将时钟配置好了。 </p><h2 id="2-2-SystemInit"><a href="#2-2-SystemInit" class="headerlink" title="2.2-SystemInit()"></a>2.2-SystemInit()</h2><p>SystemInit()函数在文件system_stm32f10x.c文件中，这个文件主要是用来配置系统时钟。现对其代码进行逐项分析。  </p><pre><code>/* Reset the RCC clock configuration to the default reset state(for debug purpose) */  /* Set HSION bit */  RCC-&gt;CR |= (uint32_t)0x00000001;  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */#ifndef STM32F10X_CL  RCC-&gt;CFGR &amp;= (uint32_t)0xF8FF0000;#else  RCC-&gt;CFGR &amp;= (uint32_t)0xF0FF0000;#endif /* STM32F10X_CL */    /* Reset HSEON, CSSON and PLLON bits */  RCC-&gt;CR &amp;= (uint32_t)0xFEF6FFFF;  /* Reset HSEBYP bit */  RCC-&gt;CR &amp;= (uint32_t)0xFFFBFFFF;  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */  RCC-&gt;CFGR &amp;= (uint32_t)0xFF80FFFF;  </code></pre><p>该段代码主要是完成寄存器初始化功能。例如代码”RCC-&gt;CR &amp;&#x3D; (uint32_t)0xFFFBFFFF;”就相当于CC-&gt;CR &amp;&#x3D;1111 1111 1111 1011 1111 1111 1111 1111 也就是使得RCC的CR寄存器的第18位置为0。查数据手册可知<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/1c42690b0d73fc4d7a1a28716fade94.png"></p><pre><code>#ifdef STM32F10X_CL  /* Reset PLL2ON and PLL3ON bits */  RCC-&gt;CR &amp;= (uint32_t)0xEBFFFFFF;  /* Disable all interrupts and clear pending bits  */  RCC-&gt;CIR = 0x00FF0000;  /* Reset CFGR2 register */  RCC-&gt;CFGR2 = 0x00000000;#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)  /* Disable all interrupts and clear pending bits  */  RCC-&gt;CIR = 0x009F0000;  /* Reset CFGR2 register */  RCC-&gt;CFGR2 = 0x00000000;      #else  /* Disable all interrupts and clear pending bits  */  RCC-&gt;CIR = 0x009F0000;#endif /* STM32F10X_CL */    #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)  #ifdef DATA_IN_ExtSRAM    SystemInit_ExtMemCtl();   #endif /* DATA_IN_ExtSRAM */#endif </code></pre><p>该段代码中只执行”RCC-&gt;CIR &#x3D; 0x009F0000;”也就是RCC-&gt;CIR &#x3D;0000 0000 1001 1111 0000 0000 0000 0000，即让RCC的CIR寄存器的16、17、18、19、20、19、20、23位置1，其他位置0。查表可知其目的就是清除中断标志位<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/3b369f919260a74818dd110477fe6c5.png"><br>进入SetSysClock()函数</p><pre><code>  SetSysClock();#ifdef VECT_TAB_SRAM  SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */#else  SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */#endif &#125;</code></pre><h2 id="2-3-SetSysClock"><a href="#2-3-SetSysClock" class="headerlink" title="2.3-SetSysClock()"></a>2.3-SetSysClock()</h2><p>这是一个系统时钟判断函数，定义了哪个宏就进入到这个宏所对应的时钟系统配置函数。</p><pre><code>  static void SetSysClock(void)&#123;#ifdef SYSCLK_FREQ_HSE  SetSysClockToHSE();#elif defined SYSCLK_FREQ_24MHz  SetSysClockTo24();#elif defined SYSCLK_FREQ_36MHz  SetSysClockTo36();#elif defined SYSCLK_FREQ_48MHz  SetSysClockTo48();#elif defined SYSCLK_FREQ_56MHz  SetSysClockTo56();  #elif defined SYSCLK_FREQ_72MHz  SetSysClockTo72();#endif</code></pre><p> 在文件system_stm32f10x.c的开头，有这些宏的定义</p><pre><code>#if defined (STM32F10X_LD_VL) || (defined STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)/* #define SYSCLK_FREQ_HSE    HSE_VALUE */ #define SYSCLK_FREQ_24MHz  24000000#else/* #define SYSCLK_FREQ_HSE    HSE_VALUE *//* #define SYSCLK_FREQ_24MHz  24000000 */ /* #define SYSCLK_FREQ_36MHz  36000000 *//* #define SYSCLK_FREQ_48MHz  48000000 *//* #define SYSCLK_FREQ_56MHz  56000000 */#define SYSCLK_FREQ_72MHz  72000000#endif</code></pre><p>STM32F10X的型号有如下：<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/9849c35821adf143a0b69202150ddc4.png"><br>其中D表示密度(Density)，V表示容量(Volume)。<br>我们使用的是STM32F10X_HD型号，所以执行的是else中的语句定义了宏SYSCLK_FREQ_72MHz，相应的执行时钟配置函数为 SetSysClockTo72()。若要选择其他系统时钟只需将前面的“&#x2F;*”去除即可调用相应的宏所对应的系统时钟配置函数。</p><h2 id="2-4-SetSysClockTo72-函数"><a href="#2-4-SetSysClockTo72-函数" class="headerlink" title="2.4-SetSysClockTo72()函数"></a>2.4-SetSysClockTo72()函数</h2><p>SetSysClockTo72()函数代码总体分为总线时钟配置、系统时钟源的选择两个部分。其代码思路如下：<br>使能 HSE，并等待 HSE 稳定-&gt;等待 HSE 启动稳定，并做超时处理(HSE 启动成功，则继续往下处理,否则可以自己编写相应的报警代码)-&gt;使能 FLASH 预存取缓冲区-&gt;设置 AHB、 APB2、 APB1 预分频因子-&gt;设置 PLL 时钟来源，设置 PLL 倍频因子， PLLCLK &#x3D; HSE * 9 &#x3D; 72 MHz-&gt;使能 PLL-&gt;等待 PLL 稳定-&gt;选择 PLL 作为系统时钟来源-&gt;读取时钟切换状态位，确保 PLLCLK 被选为系统时钟</p><h3 id="2-4-1-总线时钟的分频"><a href="#2-4-1-总线时钟的分频" class="headerlink" title="2.4.1-总线时钟的分频"></a>2.4.1-总线时钟的分频</h3><p><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/e69e2dd96541cf78dc354f6dc293566.png"><br>各个RCC寄存器的主要作用<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/a66df341e8d20a2affbdc1a03205226.png"><br>代码分析</p><pre><code>/* SYSCLK, HCLK, PCLK2 and PCLK1 configuration（开启外部高速时钟） ---------------------------*/      /* Enable HSE */      RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON);</code></pre><p>在stm32f10x.h中RCC_CR_HSEON被宏定义成0x00010000，则这句代码的意思是将RCC中的寄存器CR的第16位置为1，其他位置为0。查数据手册知其目的是开启外部高速时钟。<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/85b0ff61a42abc0e9c1481e3992ff65.png"></p><pre><code>/* Wait till HSE is ready and if Time out is reached exit */  do  &#123;    HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY;    StartUpCounter++;    &#125; while((HSEStatus == 0) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT));</code></pre><p>开启HSE后，该段代码等待HSE返回准备就绪标志位。在stm32f10x.h中RCC_CR_HSERDY被宏定义成(uint32_t)0x00020000，所以读取RCC中CR寄存器的第17位，并将其返回给HSEstatus.查数据手册知第17位是外部高速时钟就绪标志 (External high-speed clock ready flag) <img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/7a346b396fa75d17e4b988cc8d9710d.png">do-while循环结束的标志是外部时钟准备就绪标志位为1且等待时间不超时。我们在使能时钟源后都要等待其返回就绪。</p><pre><code>if (HSEStatus == (uint32_t)0x01)  &#123;    /* Enable Prefetch Buffer */    FLASH-&gt;ACR |= FLASH_ACR_PRFTBE;    /* Flash 2 wait state */    FLASH-&gt;ACR &amp;= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);    FLASH-&gt;ACR |= (uint32_t)FLASH_ACR_LATENCY_2;     </code></pre><p>如果就绪位返回为1，则执行接下来代码。FLASH_ACR_PRFTBE在stm32f10x.h文件中定义成(uint8_t)0x10，故在FLASH的ACR寄存器中的第4位写入1，其他位保持不变，查阅STM32F10***闪存编程手册可知其最终的结果是启用预取缓冲区。因为CPU的速度远大于存储器的速度，所以此处要2个等待状态<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/c2100189eb5b476586692809695ef4c.png">  </p><pre><code> /* HCLK = SYSCLK */    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;          /* PCLK2 = HCLK */    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;        /* PCLK1 = HCLK/2 */    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;</code></pre><p>第一句代码使HCLK(High-speed Clock,提供给高速总线AHB的时钟信号)等于系统时钟，由时钟系统框图可知AHB预分频器置为1（不分频），由STM32中文手册时钟配置寄存器(RCC_CFGR)可知其不分频时全部置0。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/4ea398a3d3a0af055ad9b9a923615ea.png"><br>第二句代码使PCLK2(Peripheral Clock,提供给低速总线APB2的时钟信号)等于HCLK，由时钟系统框图可知APB2-prescaler(APB2预分频器)置为1（不分频），由STM32中文手册时钟配置寄存器(RCC_CFGR)可知其不分频时全部置0。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/bc7d79867ec68385daef28c8a1df9e9.png"><br>第三句代码使PCLK1(Peripheral Clock,提供给低速总线APB1的时钟信号)等于HCLK的一半，由时钟系统框图可知AHB预分频器置为2（二分频），由STM32中文手册时钟配置寄存器(RCC_CFGR)可知其8-10位应为100，所以RCC-&gt;CFGR |&#x3D;0x00000400,也就是0000 0000 0000 0000 0000 0100 0000 0000，而事实上：</p><pre><code>#define  RCC_CFGR_PPRE1_DIV2       ((uint32_t)0x00000400)        /*!&lt; HCLK divided by 2 */</code></pre><h3 id="2-4-2-系统时钟源的选择"><a href="#2-4-2-系统时钟源的选择" class="headerlink" title="2.4.2-系统时钟源的选择"></a>2.4.2-系统时钟源的选择</h3><pre><code>#else/*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |                                        RCC_CFGR_PLLMULL));    RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);</code></pre><p>该段代码将外部高速时钟源不分频再经锁相环9倍频成为72M系统时钟源。</p><pre><code>/* Enable PLL */    RCC-&gt;CR |= RCC_CR_PLLON;    /* Wait till PLL is ready */    while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0)    &#123;    &#125;</code></pre><p>开启锁相环PLL,锁相环在SystemInit()函数中配置时钟控制寄存器(RCC_CR) 时已经关闭，因为在配置时钟配置寄存器(RCC_CFGR) 时很多位的写入需要将锁相环关闭。开启锁相环还需等待其返回PLL时钟就绪标志 (PLL clock ready flag)。<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/50d36d7865f08a2a00871f4349946c9.png"><br>选择PLL作为系统时钟源，并判断其系统时钟切换状态</p><pre><code> /* Select PLL as system clock source */    RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_SW));    RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_SW_PLL;        /* Wait till PLL is used as system clock source */    while ((RCC-&gt;CFGR &amp; (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)    &#123;    &#125;</code></pre><p><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/8f9688bffd8918a32ab1e774e703e86.png"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</category>
      
      
      
      <comments>http://example.com/2023/02/28/STM32%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于GPIO三个寄存器：ODR、BSRR、BRR功能的理解</title>
      <link>http://example.com/2023/02/26/%E5%85%B3%E4%BA%8EGPIO%E4%B8%89%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%9AODR%E3%80%81BSRR%E3%80%81BRR%E5%8A%9F%E8%83%BD%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <guid>http://example.com/2023/02/26/%E5%85%B3%E4%BA%8EGPIO%E4%B8%89%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%9AODR%E3%80%81BSRR%E3%80%81BRR%E5%8A%9F%E8%83%BD%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      <pubDate>Sun, 26 Feb 2023 06:46:07 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;首先ODR、BSRR、BRR三个寄存器都能控制引脚输出高低电平，它们在使用规则以及简易程度上有所不同。&lt;/p&gt;
&lt;h1 id=&quot;ODR&quot;&gt;&lt;a href=&quot;#ODR&quot; class=&quot;headerlink&quot; title=&quot;ODR&quot;&gt;&lt;/a&gt;ODR&lt;/h1&gt;&lt;p&gt;ODR：输出端</description>
        
      
      
      
      <content:encoded><![CDATA[<p>首先ODR、BSRR、BRR三个寄存器都能控制引脚输出高低电平，它们在使用规则以及简易程度上有所不同。</p><h1 id="ODR"><a href="#ODR" class="headerlink" title="ODR"></a>ODR</h1><p>ODR：输出端口寄存器 Output data register。ODR寄存器, 控制管脚的高、低电平，低16位有效，写1高电平，写0低电平。具体如图所示：<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/1f35b69b1c4b6984db6ebf4eed65336.png"><br>我们可以采用如下代码实现GPIO的0引脚交替输出高低电平：</p><pre><code>GPIOB-&gt;ODR |=(1&lt;&lt;0);Delay(0xFFFFF);GPIOB-&gt;ODR = 0;Delay(0xFFFFF);</code></pre><h1 id="BSRR"><a href="#BSRR" class="headerlink" title="BSRR"></a>BSRR</h1><p>BSRR寄存器, 控制管脚的高、低电平，32位有效，低16位写1 高电平，高16位写1 低电平。具体如图所示：<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/b96dde7fd93a54382d278cd0046b9a0.png"><br>在stm32f10x_gpio.c文件中给出了它的使用方法：</p><pre><code>void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)&#123;  /* Check the parameters */   assert_param(IS_GPIO_ALL_PERIPH(GPIOx));  assert_param(IS_GPIO_PIN(GPIO_Pin));  GPIOx-&gt;BSRR = GPIO_Pin;&#125;</code></pre><p>GPIO_SetBits函数是用来使对应引脚输出高电平，这里的assert是断言，用来判断输入的参数是否合法。为什么将对应引脚”GPIO_Pin”(16位)赋值给BSRR就能使其输入高电平呢？<br>这个问题困扰了我蛮久，直到我查找了stm32f10x_gpio.h文件中对0~15个引脚的的定义就明白了，如图：<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/b682ea84bf422867c05320929500387.png"><br>比如这里对低13号引脚的定义，不是将13简单的转化为二进制1101，而是将16个位置上的第14位置1，其他位置0，即：<br>0010 0000 0000 0000<br>转化成十六进制就是0x2000，这样将该引脚的16位赋值给BSRR的低十六位时，就能保证在13引脚被赋值1，其他引脚赋值0，再根据BSRR的使用特点知13引脚输出高电平，其他引脚不变。<br>我们利用BSRR的高16位，采用如下代码就可以实现对应GPIO引脚输出低电平。</p><pre><code>void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)&#123;  /* Check the parameters */  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));  assert_param(IS_GPIO_PIN(GPIO_Pin));    GPIOx-&gt;BSRR = (PIO_Pin&lt;&lt;16);&#125;</code></pre><p>如此看来，仅使用一个寄存器BSRR就可以使GPIO引脚输出高低电平，实时也是如此，F1和F4系列都有ODR和BSRR，但F4 取消了BRR。所以为了代码通用，尽量不使用BRR，反正BSRR能完成。  </p><h1 id="BRR"><a href="#BRR" class="headerlink" title="BRR"></a>BRR</h1><p>BRR寄存器, 控制管脚的低电平，低16位有效，写1 低电平。具体如图所示<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/c2434bad7a8843ceabad643ba2d76e2.png"><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/a5233e2228d2c96e785cb8ad078ddd5.png"><br>在stm32f10x_gpio.c文件中给出了它的使用方法：</p><pre><code>void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)&#123;  /* Check the parameters */  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));  assert_param(IS_GPIO_PIN(GPIO_Pin));    GPIOx-&gt;BRR = GPIO_Pin;&#125;</code></pre><p>GPIO_ResetBits函数是用来使对应引脚输出低电平，分析方法与GPIO_SetBits函数使对应引脚输出低电平类似，不再赘述。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</category>
      
      
      
      <comments>http://example.com/2023/02/26/%E5%85%B3%E4%BA%8EGPIO%E4%B8%89%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%9AODR%E3%80%81BSRR%E3%80%81BRR%E5%8A%9F%E8%83%BD%E7%9A%84%E7%90%86%E8%A7%A3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>单片机常见英文缩写</title>
      <link>http://example.com/2023/02/25/%E5%8D%95%E7%89%87%E6%9C%BA%E5%B8%B8%E8%A7%81%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99/</link>
      <guid>http://example.com/2023/02/25/%E5%8D%95%E7%89%87%E6%9C%BA%E5%B8%B8%E8%A7%81%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99/</guid>
      <pubDate>Sat, 25 Feb 2023 12:13:07 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;RCC:        振荡－阻塞变换器         Ringing Choke(阻塞) Converter&lt;br&gt;APB:        外围总线                Advanced Peripheral(外围的) Bus&lt;br&gt;GPIO:        </description>
        
      
      
      
      <content:encoded><![CDATA[<p>RCC:        振荡－阻塞变换器         Ringing Choke(阻塞) Converter<br>APB:        外围总线                Advanced Peripheral(外围的) Bus<br>GPIO:        通用输入&#x2F;输出                 General Purpose Input Output<br>HSE Osc:                        High Speed External Oscillator(振荡器)<br>AHB:        高级高性能总线                Advanced High performance Bus<br>PLL:          锁相环                        Phase Locked Loop<br>FWLib:        固件库                        Firmware Library<br>TVS：        瞬态电压抑制器        Transient Voltage Suppressor<br>CMRR:        共模抑制比<br>CRL          端口配置低寄存器     configuration registe low<br>CRH          端口配置高寄存器     configuration registe high<br>ODR：        输出端口寄存器       Output data register<br>NVIC:        嵌套向量中断控制器  Nested Vectored Interrupt Controller (NVIC)<br>TDI:        传输驱动程序接口         Transport Driver(驱动) Interface(接口)<br>ROM：       只读存储器                   Read Only Memory<br>RAM:         随机存储器               Random Access Memory<br>MCU：        微控制单元                Microcontroller Unit<br>IEEE：      电气和电子工程师协会        Institute of Electrical and Electronics     Engineers<br>ADC：       模数变换器                        Analog-to-Digital Converter<br>SPI：       串行外设接口                Serial Peripheral Interface<br>PWM：       脉冲宽度调制                 Pulse Width Modulation<br>USART：通用同步异步收发机        Universal Synchronous Asynchronous Receiver   Transmitter<br>IRQ：中断请求                        Interrupt Request<br>RTC：实时时钟                        Real-Time Clock<br>DMA ：直接存储器访问                Direct Memory Access<br>SDIO：安全数字输入输出卡        Secure Digital Input and Output Card<br>TXD:发送数据                        Transmit(tx) Data<br>RXD:接收数据                        Receive(rx) Data<br>out_pp      推挽输出                       push put<br>HSE         高速外部时钟信号            High Speed External Clock signal<br>RCC         时钟控制                    reset and clock control<br>NVIC        嵌套中断向量控制器                          Nested Vectored interrupt</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</category>
      
      
      
      <comments>http://example.com/2023/02/25/%E5%8D%95%E7%89%87%E6%9C%BA%E5%B8%B8%E8%A7%81%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>电解水实验</title>
      <link>http://example.com/2023/02/23/%E7%94%B5%E8%A7%A3%E6%B0%B4%E5%AE%9E%E9%AA%8C/</link>
      <guid>http://example.com/2023/02/23/%E7%94%B5%E8%A7%A3%E6%B0%B4%E5%AE%9E%E9%AA%8C/</guid>
      <pubDate>Thu, 23 Feb 2023 04:21:57 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;点击视频：&lt;img src=&quot;https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/1bd11a265a4d38237ab061f8bc8065bd.mp4&quot;&gt;&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>点击视频：<img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/1bd11a265a4d38237ab061f8bc8065bd.mp4"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%9D%82%E8%B0%88%E7%90%90%E7%A2%8E/">杂谈琐碎</category>
      
      
      
      <comments>http://example.com/2023/02/23/%E7%94%B5%E8%A7%A3%E6%B0%B4%E5%AE%9E%E9%AA%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>水果电池实验</title>
      <link>http://example.com/2023/02/23/%E6%B0%B4%E6%9E%9C%E7%94%B5%E6%B1%A0%E5%AE%9E%E9%AA%8C/</link>
      <guid>http://example.com/2023/02/23/%E6%B0%B4%E6%9E%9C%E7%94%B5%E6%B1%A0%E5%AE%9E%E9%AA%8C/</guid>
      <pubDate>Thu, 23 Feb 2023 03:19:02 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;材料：4个柠檬、铜片、锌片、LED灯、若干导线&lt;br&gt;&lt;img src=&quot;https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/61efb300458ec44f8b40847ea4cdfa3.jpg&quot;&gt;&lt;br&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>材料：4个柠檬、铜片、锌片、LED灯、若干导线<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/61efb300458ec44f8b40847ea4cdfa3.jpg"><br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/8a6937fb98abf0b1e53e6109d388fc9.jpg"><br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/3cddb52eae44093c5f55534ec6da685.jpg"><br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/28504674a2c9e1226fc4bd8caa70df4.jpg"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%9D%82%E8%B0%88%E7%90%90%E7%A2%8E/">杂谈琐碎</category>
      
      
      
      <comments>http://example.com/2023/02/23/%E6%B0%B4%E6%9E%9C%E7%94%B5%E6%B1%A0%E5%AE%9E%E9%AA%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>stm32相邻寄存器地址差4</title>
      <link>http://example.com/2023/02/22/stm32%E7%9B%B8%E9%82%BB%E5%AF%84%E5%AD%98%E5%99%A8%E5%9C%B0%E5%9D%80%E5%B7%AE4/</link>
      <guid>http://example.com/2023/02/22/stm32%E7%9B%B8%E9%82%BB%E5%AF%84%E5%AD%98%E5%99%A8%E5%9C%B0%E5%9D%80%E5%B7%AE4/</guid>
      <pubDate>Wed, 22 Feb 2023 10:39:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;stm32是32位CPU,CPU内部及外部一次最多可处理32位二进制数据，内存总线也是32位。&lt;br&gt;单片机的内存单元是一个字节，也就是8bite。CPU一次读取数据就要读取32位数据，也就是4字节，读取一个寄存器的信息，所以一个寄存器应占有4字节。&lt;br&gt;注意：寄存器地址</description>
        
      
      
      
      <content:encoded><![CDATA[<p>stm32是32位CPU,CPU内部及外部一次最多可处理32位二进制数据，内存总线也是32位。<br>单片机的内存单元是一个字节，也就是8bite。CPU一次读取数据就要读取32位数据，也就是4字节，读取一个寄存器的信息，所以一个寄存器应占有4字节。<br>注意：寄存器地址！&#x3D;内存地址，寄存器地址只是内存空间的编号，他不占用寄存器的物理空间，根据这个编号CPU可以改变寄存器内部的实参（利用指针）。stm32能表示4GB的内存空间，并不意味着它有$2^{32}$个地址，实际理论上只有$2^{16}$个地址。<br>我们所说的地址0x0000 0001这里的1并不是1位，而是一个字节，因为单片机存储的最小单元是一个字节8位，问们给内存编地址增量1指的是最小内存单元增加1。<br>而正因为寄存器的地址偏移4，如果定义一个寄存器的类型为(unsigned int)就正好在内存中占据4个字节，而一个内存单元就是一个字节，分配一个地址，那4个字节就正好每次偏移4个地址，而且又符合结构体的内对其，所以我们常将寄存器定义在一个结构体中，通过访问&#x2F;赋值结构体成员来访问&#x2F;赋值寄存器。如图所示：<br><img src="https://blogpicture123.oss-cn-qingdao.aliyuncs.com/picture/51af7831294100c41a786bba9ca7dd5.png"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</category>
      
      
      
      <comments>http://example.com/2023/02/22/stm32%E7%9B%B8%E9%82%BB%E5%AF%84%E5%AD%98%E5%99%A8%E5%9C%B0%E5%9D%80%E5%B7%AE4/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
